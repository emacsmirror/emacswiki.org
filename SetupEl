setup.el provides a macro to ease repetitive configuration patterns in Emacs. This is done by providing context sensitive local macros, that expand to regular, pure EmacsLisp.

The package is available on GnuELPA and is currently maintained by PhilipKaludercic on SourceHut: https://git.sr.ht/~pkal/setup.

Setup is self-documented: To get an overview of all known local macros, just read the DocString for the setup macro.

== Basics ==

The setup macro is to be used in your InitFile. By default, it behaves just like progn, evaluating everything at once. What it introduces are context-sensitive local macros. Understanding what setup.el does means understanding the previous sentence. These macros are "local" because they can only be used within a setup body. They are "context-sensitive", because their expansion can depend on where they are written. The context may include the current feature that is being configured, the current mode, the current hook, the current map, etc.

Each setup body may start with a name, that sets the feature-context for the current body. Without this, no default context is set.

E.g.

{{{
(setup foo-mode
  (:hook bar-mode))
}}}

expands to

{{{
(add-hook 'foo-mode-hook #'bar-mode)
}}}

As the context says the current mode is "foo-mode", and it's hook is "foo-mode-hook". The :hook macro uses this, to generate an add-hook call for "bar-mode".

Some configuration must wait for a feature to be loaded. Setup takes care of this automatically, e.g. when binding commands to a mode-map, the :bind macro uses WithEvalAfterLoad:

{{{
(setup foo-mode
  (:bind "C-'" quux))
}}}

expands to

{{{
;; The macroexpansion has been slightly prettified for legibility 
(with-eval-after-load foo-mode
  (define-key foo-mode-map (kbd "C-'") #'quux))
}}}

The context can be changed, using macros like :with-feature, :with-mode, :with-hook, etc.:

{{{
(setup foo-mode
  (:with-mode baz-mode
    (:hook qux-mode))
  (:hook bar-mode))
}}}

expands to

{{{
(progn
  (add-hook 'baz-mode-hook #'qux-mode)
  (add-hook 'foo-mode-hook #'bar-mode))
}}}

In fact, whenever a context is set as the first argument to setup, this could be seen as the equivalent code to:

{{{
(setup 
  (:with-feature foo-mode
    (:hook bar-mode)))
}}}

Note how  setup still works fine, even though the first element is no a symbol. Generally, the first element doesn't have to be a symbol, if the local macro provides a "shorthand" to extract a context. For example the :package keyword (that ensures a package is installed), can be used as the first form, and it uses the package name as the context:

{{{
(setup (:package foo-mode)
  (:hook bar-mode))
}}}

is equivalent to

{{{
(setup foo-mode
  (:package foo-mode)
  (:hook bar-mode))
}}}

This demonstrates what the phrase "context sensitive local macro" means: The macros :hook, :bind, etc. can all only be used within a setup body, and they make use of whatever the surrounding code defines, to infer what hook a function should be added to or what map to bind keys into. 

All local macros are defined using the function "setup-define". If you want to inspect the definition of a macro, just use, setup provides Xref integration so that M-. should just work.

== Examples ==

Configure FlyMake, by binding a few commands to the local mode, and hooking flymake-mode into prog-mode-hook:1

{{{
(setup flymake
  (:bind "M-n" #'flymake-goto-next-error
         "M-p" #'flymake-goto-prev-error)
  (:hook-into prog-mode))
}}}

Configure DirEd to load dired-x when started, prepend a value to dired-guess-shell-alist-user, customize dired-dwim-target (both using the customization interface) and then add auto-revert-mode to the mode hook.

{{{
(setup dired
  (:also-load dired-x)
  (:option (prepend dired-guess-shell-alist-user) '("" "xdg-open")
           dired-dwim-target t)
  (:hook auto-revert-mode))
}}}

This expression will be ignored if Avy is not installed. Otherwise it configures an option and binds a command to a global key, depending on whether or not Emacs is being used in the graphical mode.

{{{
(setup (:if-package avy)
  (:option avy-single-candidate-jump nil)
  (if (display-graphic-p)
      (:global "M-z" #'avy-goto-word-1)
    (:global "C-z" #'avy-goto-word-1)))
}}}

Alternatively, the check may also be pulled into the :global macro. In that case it is necessary to call kbd manually:

{{{
(setup (:package avy)
  (:option avy-single-candidate-jump nil)
  (:global (kbd (if (display-graphic-p) "M-z" "C-z"))
           #'avy-goto-word-1))
}}}

Also note that in this case :package is used instead of :if-package. This macro installs avy if it is not installed yet, before the body is evaluated further.

== Tips and Ideas ==

=== Alternative macro definer ===

If you wish to define you own macros, use setup-define. In case the
syntax is too cumbersome, you can use a macro like this:

{{{
(defmacro defsetup (name signature &rest body)
  "Shorthand for `setup-define'.
NAME is the name of the local macro.  SIGNATURE is used as the
argument list for FN.  If BODY starts with a string, use this as
the value for :documentation.  Any following keywords are passed
as OPTS to `setup-define'."
  (declare (debug defun))
  (let (opts)
	(when (stringp (car body))
	  (setq opts (nconc (list :documentation (pop body))
						opts)))
	(while (keywordp (car body))
	  (let* ((prop (pop body))
			 (val `',(pop body)))
		(setq opts (nconc (list prop val) opts))))
	`(setup-define ,name
	   (cl-function (lambda ,signature ,@body))
	   ,@opts)))
}}}

To declare local macros more like defun or defmacro. Here is how
the definition for :package could be rewritten:

{{{
(defsetup :package (package)
  "Install PACKAGE if it hasn't been installed yet."
  :repeatable t
  :shorthand #'cadr
  `(unless (package-installed-p ',package)
	   (package-install ',package)))
}}}

=== setup-based Macro ===

The first element of a `setup` body can but does not have to be a
name. That can be exploited to use `setup` in your own macros. I have
this macro in my personal configuration, when I'm only interested in
modifying user options:

{{{
(defmacro setc (&rest args)
  "Customize user options using ARGS like `setq'."
  (declare (debug setq))
  `(setup (:option ,@args)))
}}}

== Additional Keywords ==

Here are a few examples of how setup-define can be used. Feel free to add your own macros or ideas to this section (see HowToEdit).  Please add new macros to the end of this section so that the anchor links for the previous sections are preserved.

=== Autoloading ===

This can be useful when working with local Lisp files.

{{{
(setup-define :autoload
  (lambda (func)
    (let ((fn (if (memq (car-safe func) '(quote function))
                  (cadr func)
                func)))
      `(unless (fboundp (quote ,fn))
         (autoload (function ,fn) ,(symbol-name (setup-get 'feature)) nil t))))
  :documentation "Autoload COMMAND if not already bound."
  :repeatable t
  :signature '(FUNC ...))
}}}

=== Unconditional quit ===

By default, :only-if, :if-host, etc. can be used to abort the evaluation of a setup body. In some cases one might want to unconditionally abort, e.g. when using a complex conditional construct. In that case, :quit generates the right code:

{{{
(setup-define :quit
  #'setup-quit
  :documentation "Unconditionally abort the evaluation of the current body.")
}}}

=== Bound unconditional quiting ===

In case one doesn't want the entire setup body from being aborted because of :only-if, :if-host, :quit, etc. you can use this following to limit its scope:

{{{
(setup-define :with-local-quit
    (lambda (&rest body)
      `(catch ',(setup-get 'quit)
         ,@body))
  :documentation "Prevent any reason to abort from leaving beyond BODY."
  :debug '(setup))
}}}

=== Deferred Loading ===

If you want to load the current feature after a series of other features, this macro can help automatically define the code to do so:

{{{
(setup-define :load-after
    (lambda (&rest features)
      (let ((body `(require ',(setup-get 'feature))))
        (dolist (feature (nreverse features))
          (setq body `(with-eval-after-load ',feature ,body)))
        body))
  :documentation "Load the current feature after FEATURES.")
}}}

Note that multiple arguments can be passed to :after-load, leading to multiple encapsulated with-eval-after-load blocks.

=== Remove the current mode from the mode line ====

The ModeLine uses `minor-mode-alist` to map active minor modes to indicators. This macro makes manipulating the variable easier:

{{{
(setup-define :hide-mode
    (lambda (&optional mode)
      (let* ((mode (or mode (setup-get 'mode)))
             (mode (if (string-match-p "-mode\\'" (symbol-name mode))
                       mode
                     (intern (format "%s-mode" mode)))))
        `(setq minor-mode-alist
               (delq (assq ',mode minor-mode-alist)
                     minor-mode-alist))))
  :documentation "Hide the mode-line lighter of the current mode.
Alternatively, MODE can be specified manually, and override the
current mode."
  :after-loaded t)
}}}

=== Removing hooks ===

It is sometimes desirable to modify hooks buffer-locally, such as in the case of `flymake-diagnostic-functions'.

{{{
(setup-define :unhook
  (lambda (func)
    `(remove-hook (quote ,(setup-get 'hook)) ,func))
  :documentation "Remove FUNC from the current hook."
  :repeatable t
  :ensure '(func)
  :signature '(FUNC ...))

(setup-define :local-unhook
  (lambda (hook &rest functions)
    `(add-hook
      (quote ,(setup-get 'hook))
      (lambda ()
        ,@(mapcar
           (lambda (arg)
             (let ((fn (cond ((eq (car-safe arg) 'function) arg)
                             ((eq (car-safe arg) 'quote)    `(function ,(cadr arg)))
                             ((symbolp arg)                 `(function ,arg))
                             (t                             arg))))
               `(remove-hook (quote ,hook) ,fn t)))
           functions))))
  :documentation "Remove FUNCTION from HOOK only in the current hook."
  :debug '(&rest sexp)
  :repeatable nil)
}}}

This can be used like so:

{{{
(setup flymake
  (:hook-into prog-mode text-mode org-src-mode)
  (:with-mode org-src-mode
    (:local-unhook flymake-diagnostic-functions #'elisp-flymake-checkdoc)))
}}}

=== Add advice ===

The following macro simplifies the definition of [[Advice]]:

{{{
(setup-define :advise
    (lambda (symbol where arglist &rest body)
      (let ((name (gensym "setup-advice-")))
	`(progn
	   (defun ,name ,arglist ,@body)
	   (advice-add ',symbol ,where #',name))))
  :documentation "Add a piece of advice on a function.
See `advice-add' for more details."
  :after-loaded t
  :debug '(sexp sexp function-form)
  :indent 3)
}}}

an alternative implementation might be given a function as an advice argument instead of 
constructing a new function.

{{{
(setup-define :advise
    (lambda (symbol where function)
      `(advice-add ',symbol ,where ,function))
  :documentation "Add a piece of advice on a function.
See `advice-add' for more details."
  :after-loaded t
  :debug '(sexp sexp function-form)
  :ensure '(nil nil func)
  :repeatable t)
}}}

=== Check for executables ===

If you wish to only configure a system when a executable is installed, the following macro 
will ensure that the evaluation is interrupted, when this is not the case:

{{{
(setup-define :needs
    (lambda (executable)
      `(unless (executable-find ,executable)
         ,(setup-quit)))
  :documentation "If EXECUTABLE is not in the path, stop here."
  :repeatable 1)
}}}

===  Hostname checking ===

You sometimes want to configure a system only on one host. The following macro can be used to 
easily check your hostname, and prevent evaluation of a setup body, if you are on the "wrong" 
host:

{{{
(setup-define :if-host
    (lambda (hostname)
      `(unless (string= (system-name) ,hostname)
         ,(setup-quit)))
  :documentation "If HOSTNAME is not the current hostname, stop evaluating form.")
}}}

=== Manual <code>load-path</code> manipulation ===

If you want to add a directory to your <code>load-path</code> the following macro can do so.  
Additionally, it will abort the evaluation if the directory doesn't exist and can be used as
the head element.

{{{
(setup-define :load-from
    (lambda (path)
      `(let ((path* (expand-file-name ,path)))
         (if (file-exists-p path*)
             (add-to-list 'load-path path*)
           ,(setup-quit))))
  :documentation "Add PATH to load path.
This macro can be used as NAME, and it will replace itself with
the nondirectory part of PATH.
If PATH does not exist, abort the evaluation."
  :shorthand (lambda (args)
               (intern
                (file-name-nondirectory
                 (directory-file-name (cadr args))))))
}}}

=== Install PACKAGE with MIN-VERSION or higher ===

Based on the require-package function from here: https://github.com/purcell/emacs.d/blob/master/lisp/init-elpa.el

I was advised to use a separate function instead of putting everything inside the keyword 
definition, which would minimize code when expanded. Feel free to modify and post that 
version.

{{{
(setup-define :package-min-version
    (lambda (package min-version)
      `(let ((min-version (quote ,min-version)))
         (when (stringp min-version)
           (setq min-version (version-to-list min-version)))
         (unless (package-installed-p ',package min-version)
           (cl-labels
               ((find-best (pkg)
                           (car (sort (cdr (assoc pkg package-archive-contents))
                                      (lambda (a b)
                                        (version-list-<= (package-desc-version b)
                                                         (package-desc-version a))))))
                (good-enough (pkg)
                             (and pkg
                                  (version-list-<= min-version (package-desc-version pkg)))))
             (let
                 ((best-pkg (find-best ',package)))
               (if (good-enough best-pkg)
                   (package-install best-pkg)
                 (package-refresh-contents)
                 (let ((best-pkg (find-best ',package)))
                   (if (good-enough best-pkg)
                       (package-install best-pkg)
                     (error "No version of %s >= %S is available" ',package min-version))))))
           (package-installed-p ',package min-version))))
    :documentation "Install PACKAGE with MIN-VERSION or higher if it hasn't been installed yet.
      This macro can be used as NAME, and it will replace itself with
      the first PACKAGE."
    :repeatable t
    :shorthand #'cadr)
}}}

=== Using straight.el ===

StraightEl ([https://github.com/raxod502/straight.el on GitHub]) is a "next-generation, purely functional package manager for the Emacs hacker," according to its repo.  I like using it is all I know.  Here's a :straight keyword for setup:

{{{
(setup-define :straight
  (lambda (recipe)
    `(unless (straight-use-package ',recipe)
       ,(setup-quit)))
  :documentation
  "Install RECIPE with `straight-use-package'.
This macro can be used as HEAD, and will replace itself with the
first RECIPE's package."
  :repeatable t
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe)
                     (car recipe)
                   recipe))))
}}}

In addition, I find it convenient to only install a package given a certain predicate evaluates to t.  I prefer this local macro over :needs, :if-feature, and others because this stops the package from being installed if a certain condition isn't met.

{{{
(setup-define :straight-when
  (lambda (recipe condition)
    `(if ,condition
         (straight-use-package ',recipe)
       ,(setup-quit)))
  :documentation
  "Install RECIPE with `straight-use-package' when CONDITION is met.
If CONDITION is false, stop evaluating the body.  This macro can
be used as HEAD, and will replace itself with the RECIPE's
package.  This macro is not repeatable."
  :repeatable nil
  :indent 1
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe) (car recipe) recipe))))
}}}

Note that this macro can also be reproduced using :and:

{{{
(setup (:and (some-condition)
	     (:straight foo))
  (the rest of the body))
}}}

=== Using Elpaca ===

[https://github.com/progfolio/elpaca Elpaca] is an elisp package manager. It is a replacement for the built-in Emacs package manager, package.el. We can extend SetupEl's functionality using <code>setup-modifier-list</code> and wrap SetupEl bodies in an Elpaca call, this requires installing and processing the package first:

*Note*: Initial startup will give the error <code>Symbol's value as variable is void: setup-modifier-list</code> as Elpaca doesnt have a way of doing a blocking install.

{{{
;; <elpaca bootstrap goes here>

(elpaca setup (require 'setup))
(elpaca-process-queues)
}}}

Then we can set up the wrapping functionality:

{{{
(defun setup-wrap-to-install-package (body _name)
  "Wrap BODY in an `elpaca' block if necessary.
The body is wrapped in an `elpaca' block if `setup-attributes'
contains an alist with the key `elpaca'."
  (if (assq 'elpaca setup-attributes)
      `(elpaca ,(cdr (assq 'elpaca setup-attributes)) ,@(macroexp-unprogn body))
    body))

;; Add the wrapper function
(add-to-list 'setup-modifier-list #'setup-wrap-to-install-package)

(setup-define :elpaca
  (lambda (order &rest recipe)
    (push (cond
           ((eq order t) `(elpaca . ,(setup-get 'feature)))
           ((eq order nil) '(elpaca . nil))
           (`(elpaca . (,order ,@recipe))))
          setup-attributes)
    ;; If the macro wouldn't return nil, it would try to insert the result of
    ;; `push' which is the new value of the modified list. As this value usually
    ;; cannot be evaluated, it is better to return nil which the byte compiler
    ;; would optimize away anyway.
    nil)
  :documentation "Install ORDER with `elpaca'.
The ORDER can be used to deduce the feature context."
  :shorthand #'cadr)
}}}

Now we can install packages. Using shorthand functionality to determain package name:

{{{
(setup (:elpaca avy)
  (the rest of the body))
}}}

Full Elpaca "orders" are supported, with shorthand:

{{{
(setup (:elpaca avy :host github :repo "abo-abo/avy")
  (the rest of the body))
}}}

Use feature context as the package name to install:

{{{
(setup avy
  (:elpaca t)
  (the rest of the body))
}}}

Dont install anything, but account for asynchronous installation:

{{{
(setup avy
  (:elpaca nil)
  (the rest of the body))
}}}

See [https://github.com/progfolio/elpaca#installing-packages elpaca#installing-packages] for an explanation on a <code>nil</code> "order".

=== Install a package if not available locally ===

This macro builds up on :package, but also checks if <code>feature-or-package</code>
could be found in the load path.

{{{
(setup-define :local-or-package
  (lambda (feature-or-package)
    `(unless (locate-file ,(symbol-name feature-or-package)
			  load-path
			  (get-load-suffixes))
       (:package ',feature-or-package)))
  :documentation "Install PACKAGE if it is not available locally.
This macro can be used as NAME, and it will replace itself with
the first PACKAGE."
  :repeatable t
  :shorthand #'cadr)
}}}

=== A prefix-less alternative to :option ===

When customizing a package that uses a symbol prefix consistently, you might
want to use this macro that automatically prefixes each option name with the 
current feature name:

{{{
(setup-define :option*
  (lambda (name val)
    `(customize-set-variable
      ',(intern (format "%s-%s" (setup-get 'feature) name))
      ,val
      ,(format "Set for %s's setup block" (setup-get 'feature))))
  :documentation "Set the option NAME to VAL.
NAME is not the name of the option itself, but of the option with
the feature prefix."
  :debug '(sexp form)
  :repeatable t)
}}}

So that 

{{{
(setup foo (:option* bar "baz"))
}}}

is expanded to

{{{
(customize-set-variable 'foo-bar "baz" "Set for foo's setup block")
}}}

(Alternatively, you could also re-use :option instead of customize-set-variable.

=== Specify auto-mode-alist with globs  ===

A minor variation on the built-in :file-match:

{{{
(setup-define :file-match
  (lambda (glob)
    `(add-to-list 'auto-mode-alist (cons ,(wildcard-to-regexp pat) ',(setup-get 'mode))))
  :documentation "Associate the current mode with files that match GLOB."
  :debug '(form)
  :repeatable t)
}}}


=== Customizing Faces ===

{{{
(setup-define :face
    (lambda (face spec) `(custom-set-faces (quote (,face ,spec))))
    :documentation "Customize FACE to SPEC."
    :signature '(face spec ...)
    :debug '(setup)
    :repeatable t
    :after-loaded t)
}}}

For example,

{{{
(setup (:straight forge)
    (:load-after magit)
    ;; Make it easier to see that a topic was closed.
    (:face forge-topic-closed ((t (:strike-through t)))))
}}}

=== Add documentation to setup block ===

Similar to [https://github.com/conao3/leaf.el leaf.el] :doc keyword.
The doc alist could be, for example, fed to [[marginalia]], and provide annotations to minibuffer completions.

{{{
(defvar setup--doc-alist nil "AList of docs for setup blocks.")

(setup-define :doc
  (lambda (string)
    `(add-to-list 'setup--doc-alist '(,(setup-get 'feature) . ,string)))
  :documentation "Allow documentation using STRING.
This will be ignored at expansion."
  :signature '(STRING ...)
  :repeatable nil)
}}}

== Transforming Configuration Errors Into Warnings ==

This code transforms errors in the expanded code into warnings, letting the rest of your config file run.

{{{
(defun my-protect-setup (expansion)
  "Wrap `setup' output with `condition-case'."
  (let ((err (gensym "setup-err")))
    `(condition-case ,err
	 ,expansion
       (error
	(display-warning 'setup (concat "Problem in config: "
					(error-message-string ,err)
					": \n"
					(with-output-to-string
					  (pp (quote ,expansion))))
			 :error)))))

(advice-add 'setup :filter-return #'my-protect-setup)
}}}

[new:PhilipKaludercic:2022-11-19 10:57 UTC]
You should already be able to do this by adding <code>setup-wrap-to-demote-errors</code> to <code>setup-modifier-list</code> -- without the need for any advice.

== Example Configurations ==

=== Vertico and co. ===

This block would configure the [[Vertico]], [[Marginalia]], [[Consult]], [[Orderless]], [[Embark]] completion framework:

{{{
(setup (:package vertico marginalia consult orderless embark)
  ;; Vertico
  (:option vertico-mouse-mode t
           vertico-reverse-mode t
           vertico-count 8
           vertico-resize t
           vertico-cycle t
           vertico-mode t)
  ;; Marginalia
  (:option marginalia-mode t)
  (:bind-into minibuffer-local-map
    "M-A" marginalia-cycle)
  ;; Consult
  (:global [remap switch-to-buffer] #'consult-buffer
           [remap goto-line] #'consult-goto-line
           [remap imenu] #'consult-imenu
           [remap project-switch-to-buffer] #'consult-project-buffer
           "M-s g" (if (executable-find "rg")
                       #'consult-ripgrep
                     #'consult-grep)
           "M-s d" consult-find
           "M-s l" consult-line
           "M-s m" consult-mark
           "M-s o" consult-outline
           "M-s f" consult-flymake)
  (:option xref-show-xrefs-function #'consult-xref
           xref-show-definitions-function #'consult-xref)
  ;; Orderless
  (:option completion-styles '(orderless))
  ;; Embark
  (:global "C-'" #'embark-act
           "C-=" #'embark-dwim))
}}}

== Comparison to UsePackage ==

The most popular configuration macro for Emacs is use-package by John Wiegley.
The intention is similar, but usage is noticeably different. 
While use-package to specifies information about package and it's usage, setup is less declarative and just provides a set of context-sensitive local macros, that are simply substituted.

The higher level of abstraction allows use-package to hide some of the complexity, by transparently reordering everything into the right order.
The downside is that it is easy to get lost or forget what use-package is doing. Each setup macro on the other hand intends to encapsulate one common configuration action, and simplify the syntax. The FlyMake example from above:

{{{
(setup flymake
  (:bind "M-n" #'flymake-goto-next-error
         "M-p" #'flymake-goto-prev-error)
  (:hook-into prog-mode))
}}}

...is expanded into the following code:

{{{
(progn
  (eval-after-load 'flymake
    (function
     (lambda nil
       (progn
         (define-key flymake-mode-map
           [134217838]
           (function flymake-goto-next-error))
         (define-key flymake-mode-map
           [134217840]
           (function flymake-goto-prev-error))))))
  (add-hook 'prog-mode-hook
            (function flymake-mode)))
}}}

The macro :bind wraps define-key calls in a eval-after-load block, and automatically parses multiple arguments in a setq-like fashion. Likewise, :hook-into knows to deduce that flymake-mode should be added to prog-mode's hook (prog-mode-hook).

Furthermore use-package might be said to be less flexible, because the macro assumes a certain kind of usage. Each expression should define one package. This is not assumed for setup: Each body can just as easily configure no to as many packages as one wants.

{{{
(setup (:package company company-math)
  (:bind "TAB" company-complete))
}}}

would install both company and company-math. The context is set to company, because the :package call is the first element of the list, and company is it's first argument.

An attempt is also made by setup.el to ease extensibility. Each macro is defined using the setup-define function. Combined with further attributes, it allows for the simple definition of local and context sensitive macros, that are debug-able, can be composed and deferred.

Finally, a common question is how UsePackage :init translates into setup forms.  The answer is that it is not needed at all.  Any non-setup macro you write will be preserved by macroexpansion.  Again, as mentioned in the first section "By default, [setup] behaves just like progn".  This once more illustrates why the direct comparison with UsePackage can be counter-productive, as setup is *not* declarative, since you retain precise control over the order in which forms are evaluated.  The destinction between :init and :config doesn't make sense for setup, since anything you want to evaluate directly can just be written out, and anything that should be delayed ought to ideally be hanled by a delayed (:after-loaded) macro or if neecssary or more convenient using :when-loaded.

== Imenu Support ==

Here is a basic regular expression to help Imenu find where you use the macro.

{{{
(with-eval-after-load 'imenu
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (setf (map-elt imenu-generic-expression "Setup")
                    (list (rx line-start (0+ blank)
                              "(setup" (1+ blank)
                              (or (group-n 1 (1+ (or (syntax word)
                                                     (syntax symbol))))
                                  ;; Add here items that can define a feature:
                                  (seq "(:" (or "straight" "require" "package")
                                       (1+ blank)
                                       (group-n 1 (1+ (or (syntax word)
                                                          (syntax symbol)))))))
                          1)))))

}}}

== See Also ==

* SystemCrafters video on UsePackage alternatives, that discusses setup.el among other things https://www.youtube.com/watch?v=ZolOUgXHgbo
* Configuration using setup.el extensively: https://git.acdw.net/emacs
* Another configuration using setup.el extensively: https://github.com/mfiano/emacs-config (contains additional setup.el macros)
* Configuration of the setup.el author: https://git.sr.ht/~pkal/emacs-init/tree/master/item/init.el

----
CategoryExtensions
