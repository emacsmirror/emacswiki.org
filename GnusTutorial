This is a step-by-step guide to using [[Gnus]], an Emacs package for reading [b]Netnews[/b],
 [b][GettingMail email][/b], *RSS*, and much more. It is highly customizable.

However, all this can make it hard to learn. The [[https://www.gnu.org/software/emacs/manual/html_mono/gnus.html Gnus Manual]] 
is more of a *technical reference* than a user
guide, so new users often find it difficult to understand.


== Fundamental Configuration ==

Before using Gnus, you must tell it about you. Open (or create) ##~/.gnus.el## and enter:

{{{
(setq user-mail-address  "you@domain.com"
      user-full-name     "Your Full Name"
      mail-signature     "Most pettable Dog")

;; Instead, you may set the $EMAIL and $NAME environment variables.
}}}

Gnus needs to know where to *fetch* its messages from. In this example we specify multiple sources:

* ##foo.bar.com## -- An NNTP server.
* ##localhost## -- Our local news spool.
* ##mail.example.com## -- Our Email provider.

{{{
(setq
  gnus-select-method            '(nntp     "foo.bar.com")
  gnus-secondary-select-methods '((nnspool "localhost")
                                  (nnml    "")))

(setq mail-sources
      '((pop :server   "mail.example.com"
             :user     "Laura"
             :password "passw0rd")))
}}}

If required, Gnus will prompt for a *username* and *password* every time. To avoid this, put the following in ##~/.authinfo##

{{{
machine foo.bar.com login your_username  passwerd your_pass
machine localhost   login your_username2 password your_pass2 force yes
    
# "force yes" forces a username connection over anonymous.
}}}

Gnus needs to know how to *send* mail. ##smtpmail## is easy as it comes built-into Emacs.
Add the following lines to ##~/.gnus.el##:

{{{
(setq send-mail-function		'smtpmail-send-it
      message-send-mail-function	'smtpmail-send-it
      smtpmail-smtp-server		"mail.example.com")

;; Instead of smtpmail-smtp-server, you may set the environment variable $SMTPSERVER
}}}

Emacs' default SMTP port is [b]25[/b]. To change this, customize ##smtpmail-smtp-service##.

If your *SMTP server* requires authentication, please read 
[[http://www.gnu.org/software/emacs/manual/html_node/smtpmail/Authentication.html#Authentication This Manual page]].

== Using Gnus ==

Start Gnus with ##M-x gnus##.

Gnus will open the servers in your *select methods* and fetch *new messages*, then open the *Group buffer* where your Groups are listed.

Use ##A A## to list available groups. ##u## *subscribes* you to the selected group.

Here's an overview of common commands:

* `RET' -- Enter the group under the point
* `g' -- Check for news nd mail.
* `q' -- Quit Gnus (Always close Gnus before closing Emacs)
* `c' -- Catchup (marks all articles as read)
* <code>‘#’</code> -- Mark a group
* `l' -- Show only groups with unread articles
* `L' --Show all subscribed groups
* `m' -- Compose new Mail
* `a' -- Create a new Post
* `V' -- Display current Gnus version number.
* <code>‘^’</code> -- Enter server buffer

=== Topics ===

You may *sort* groups into "folders". Gnus calls these folders *topics*.
Hit ##t## to enter ##topic-mode##.  There are two *default* topics -- ##gnus## and ##misc##.
To make a new topic, place the cursor over a topic, and say ##T n##.

Move a group to a new Topic by saying ##T m## over the group you want to move.

If you want ##topic-mode## to be *always active*, place the following in your
##~/.gnus.el##:

{{{
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
}}}

=== Summary Buffer ===

When you *enter* a group, Gnus will fetch *headers* for that group. When it has finished, it will open a buffer showing a *summary* of each article in the group. Select an article with ##<RET>## and scroll through it with ##<SPC>## and ##<DEL>##.

To change how the Summary *looks*, customize [[https://gnus.org/manual/gnus_31.html gnus-summary-line-format]]. For example:

{{{
(setq gnus-summary-line-format "%U%R%z %d  %-30n  %B%s\n")
}}}

Here are some common keybindings:

* `C-h m' -- View all keybindings
* `RET' -- View article under point
* `n' -- Next new article
* `p' -- Previous article
* `SPC' -- Scroll down / Next article
* `DEL' -- Scroll up
* `F' -- Reply to *news* thread and quote the article.
* `R' -- Reply to *mail* and quote the sender
* `m' -- New mail
* `a' -- New Post
* `c' -- Catchup (fetch new articles)
* `/ t' -- Show old headers
* `C-u / t' -- Show only young headers
* `T T' -- Toggle threading
* `C-u g' -- Display raw article
* `g' -- Return to normal view
* `t' -- Toggle all headers
* `W w' -- Word-wrap the current article
* `W r' -- Toggle Rot13
* <code>‘^’</code> -- Fetch parent of article
* `L' -- Create a ##scorefile-entry## based on the current article (`?' for help)
* `I' -- Like `L' but high score

=== Composing Mail ===

When you use a *Compose* key (say, ##m##), you'll enter a new buffer.
Fill out the ##Subject:## header and enter your post body below ##--text follows this line--##. You may add additional headers above this line (e.g. ##X-Drunk-as-a-lord: yes##).

You likely want automatic word-wrapping. Add the following
lines in ##~/.gnus##:

{{{
(defun my-message-mode-setup ()
  (setq fill-column 72)
  (turn-on-auto-fill))

(add-hook 'message-mode-hook 'my-message-mode-setup)
}}}

Commands for composing mail:

* ##C-c C-c## -- Send message
* ##C-c C-d## -- Save message as draft
* ##C-c C-k## -- Kill message
* ##C-c C-m f## -- Attach file
* ##M-q## -- Reformat paragraph
* ##M-x message-caesar-region## -- encode region using ROT13

=== Help! ===

Soon enough (after about 17 seconds of
using Gnus), you'll find yourself in a situation where you have no idea
how to do something. Here are some ways to search for solutions:

* ##C-h i d m gnus## -- Read the Gnus Manual (Press ##s## to search).
* ##C-h ?## -- Displays the system help menu.
* ##C-h m## -- Displays the current mode's keybindings.
* ##C-h b## -- Displays all Emacs keybindings.
* The Menu Bar -- Common Gnus functions are sometimes kept here.

If you're really stuck, you can ask other Gnusers. Proper places for this are:

* gnu.emacs.gnus
* news.software.readers
* gnus.ding -- (If you're on an Alpha release)

=== Miscellaneous ===

* When Gnus asks you for an input, it is likely *tab-completable*.
* Gnus buffers are also *normal Emacs buffers*; You can use all Emacs commands from Gnus.

== Basic terminology and news reading ==

Terms I use which might be unfamiliar to you.

_say_ -- "You can *say* ##(setq my-var t)## to enable ##my-var##

_Posting, Article, Message, Mail_

All similar. I use the term *message* to refer to both email /and/ news posts,
but *mail message* and *news message* for the individual cases. "posting" and "article"
are synonymous with "message.

_Backend_

Gnus fetches messages from various sources. A *backend* describes how Gnus
*accesses* a set of messages from a server. Gnus uses the ##nntp## backend to interface with NNTP servers, and the ##nnimap## backend to talk to IMAP servers.

_Server_

Whereas a backend describes the mechanism used by Gnus to access the
messages, a server is a specific instance of that mechanism. You might
create a specific server for accessing the host news.frob.org using
NNTP, say. Or you might create a server for accessing the MH-style
directory ~/OldMail.

If you are a programmer, think of a backend as the class and of a server
as an object (instance) of that class. If you are a cook, think of a
backend as an apple pie recipe (say), and think of a server as an actual
apple pie. (Yummy!) If you live in a huge city, think of a backend as a
bus (or tram, or underground) line (the Circle Line comes to mind), and
think of a server as a specific bus (or tram train, or underground
train). The one at 8:15 last Monday morning, for example. If you drive a
car, think of a backend as the model and make and of a server as a
specific car.

Obviously, there can be two servers using the same backend. (Two
instances of the same class, two apple pies baked according to the same
recipe, two busses going the same route, two cars of the same model.)

[u](Select) method[/u]

Just another term for server.

[u]Native server[/u]

This is the *primary server*, so to speak. Most people let their news
server be the native server, hence:

          (setq gnus-select-method '(nntp "news.frob.org"))

_Secondary select methods_

A list of additional servers one wishes to use. 

Groups from a secondary server are known as *secondary groups*.

In order to be able to distinguish native groups from secondary groups,
each server is identified with a (unique) name and that name is used as
a prefix for the secondary groups. Thus, you might have a group
gnu.emacs.help (which is native) and another group nnml:mail.misc (which
is secondary). A plus character is used if the name of a server is not
the empty string. For example, given the following in your ~/.gnus.el
file

          (setq gnus-secondary-select-methods
                '((nnml "work" (nnml-directory "~/Mail.work/"))
                  (nnml "play" (nnml-directory "~/Mail.play/"))))

you might have the groups ##nnml+work:boss## and ##nnml+play:so1##.

_Group_

Well, if you've read news before, you know about different news
groups. One of my favorites is gnu.emacs.gnus, and I wish I would read
alt.fan.pratchett. Since Gnus treats mail in a newsreaderly fashion, it
is obvious that it uses groups rather than ``folders'' like other mail
readers do. So with Gnus there are news groups and mail groups, where
mail groups are known as mail folders to other programs.

Each group belongs to a certain server, and each server uses a certain
backend.

_Expiry_

News servers offer news groups which contain news postings. New news
postings come in, so the news postings accumulate, and pretty soon the
new hard disk is full. This is not good news at all.

Thus, a news server does what is known as expiry: it deletes old
messages. Of course, on a news server, expiry happens with no regard of
whether people have already seen the message in question; instead, the
news server admin chooses expiry times based on available disk space and
maybe on the normal amount of traffic in a news group.

But mail messages should be under the users' control, so there better be
no server which deletes messages regardless of users having seen them!
Instead, Gnus adopts a scheme where users say which messages may be
deleted, and Gnus takes care of deleting them after a while. (They are
not deleted immediately in case you made a mistake, or in case you wish
to refer back to an old article.)

_Article marks_

Gnus distinguishes between a number of article marks, which indicate
whether they have been looked at, or are considered important, or the
like. Marks are represented by a character.

If that character is a space, it looks as if the message isn't marked at
all. These messages are called unmarked, the mark character used is a
space, and marking a message with space is considered to be the same as
removing all marks—after all, such messages are unmarked. You can type
M-u to remove all marks and make an article unmarked.

Articles that are considered important or where you wish to indicate
that you have to deal with them later can be ticked. The mark character
used for ticked messages is the exclamation mark, and you can use u or !
to tick messages. Ticked messages are always shown when you enter a
group.

There is the dormant mark which is similar to the ticked mark but does
not imply importance or urgency; thus, dormant messages aren't shown by
default. The mark character used is the question mark, and you can mark
messages as dormant using the ? key.

So far, each kind of mark was associated with one character (as was the
absence of any mark). But articles which you have read are a bit
different, since lots of different characters are used here. The
important thing to realize is that these messages are treated in the
same way by Gnus; the different characters are only used as an
information for the user.

Articles which are marked as read because you have actually read them
(the normal case, one would think) are marked with the `R'
character. (Type <SPC> or g to read a message, or click on it using the
middle mouse button, <mouse-2>.) You can also mark a message as read
without actually reading it, this is indicated with the `r' character
and can be achieved with d or M r.

After exiting a group and then entering it again (some time later), the
messages that had been marked as read before appear with the `O'
character.

To reiterate: the difference between `r', `R' and `O' is only an
information for the user.

_Footnotes_

[1] ``SO'' standing for ``significant other'', i.e. girlfriend or
boyfriend.


== Mail ==

Gnus is primarily a news reader, but *this is a good thing*, as it turns
out "managing email in a very newsreaderly fashion" is very efficient.

It would be an uphill battle if you tried to make Gnus "behave like a /normal/
email client". Instead of telling Gnus to change, let Gnus change /you/.

You need to tell Gnus:

* How to *store* mail on the local disk.
* *Where* to get the mail messages.
* How to *send* new mail.

Later we'll mention *auto-expire* and *total-expire*, which are
useful for mail from *mailing lists* (Expiry is Gnus way of "deleting" mail).

A fourth section talks about how to *migrate old mail* into Gnus.

The difference between mail *backends* and mail *sources* is that a backend tells
Gnus how to store messages, whereas mail sources specify where to fetch them. Gnus fetches 
mail from the source, and stores it in the backend. Sources are stored in ##mail-sources##. Backends are
stored in ##gnus-secondary-select-methods##.

The ##nnimap## backend is an exception: the IMAP server itself
stores your mail; it doesn't need to be fetched.

=== Backends ===

The Gnus manual lists many backends. For news, theres:

* ##nntp## -- Access an NNTP Netnews server.
* ##nnspool## -- If you have a local news spool
** (Leafnode users should always use ##nntp##)

There are many mail backends. This list has more popular choices near the top:

* ##nnmaildir## -- Stores messages in files in a folder
* ##nnimap## -- Manages mail on server. Good if you use multiple devices.
* ##nnmbox## -- Stores messages all in one ##~/mbox## file.
* ##nnfolder## -- Uses the ##mbox## format, but uses separate files.
* ##nnml## -- Generates an "overview" file to make parsing fast.
* ##nnmh## -- The MH format where file names are numbered.
* ##nnbabyl## -- Like ##mbox## but with delimiters for message start/ends.

See MailFiles for a more complete analysis.

==== Hands-on Advice ====

FIXME: Do we want to tell people to use Customize?

All of this information is nice, but how do you actually make use of it?
Well, you have to put stuff into the ~/.gnus.el file. Here are some
examples:

The following is the most simple statement. It's what I use. This just
specifies the backend to use and leaves everything else with the default
settings.

     (add-to-list 'gnus-secondary-select-methods '(nnml ""))

It is also possible to choose a server name. With the above, you'll get
groups like nnml:foo, but with the suggestion below, they'll be named
nnml+x:foo.

     (add-to-list 'gnus-secondary-select-methods '(nnml "x"))

This is useful when you have multiple ##nnml## inboxes.

*Server parameters* are settings which you can include with your server. For example, if you use
the ##nnmbox## backend, then you can specify a different mbox file
to use (the default is ##~/mbox##):

     (add-to-list 'gnus-secondary-select-methods
                  '(nnmbox ""
                    (nnmbox-mbox-file "~/MAIL")
                    (nnmbox-active-file "~/Mail.active")))

The other server parameters can be set in a similar way. The Gnus info
file explains for each backend which server parameters are possible.

Please note one important fact, however: each server wants to own the
directories and files it writes to, and gets very angry if it finds that
they are already occupied. Therefore, the nnchoke-frumple-file and the
nnchoke-gargle-directory parameters are pretty important. For example,
if you have used Pine before Gnus, then you are going to have a ~/Mail
directory which is used by Pine. Therefore, you should add the right
parameters to tell Gnus to stay away from that directory. For example:

     (add-to-list 'gnus-secondary-select-methods
                  '(nnml ""
                    (nnml-directory "~/GnusMail/")
                    (nnml-active-file "~/GnusMail/active")))

The file-per-message and file-per-group types of backends each have a
parameter nnchoke-directory, the file-per-server type of backend has a
nnchoke-mbox-file parameter. All these backends have a
nnchoke-active-file parameter.

Of course, nnimap is an outlier where the above does not apply.

FIXME: Can somebody say something about nnmaildir, please?


=== Fetching and sending mail ===

The previous section has explained how Gnus fetches mail to read.
But the question is, how does the mail actually get to
your local disk in the first place? For many people, the answer is
*POP* ([b]P[/b]ost [b]O[/b]ffice [b]P[/b]rotocol). Gnus can connect
to a POP server, which is a remote location holding your mail.

##mail-sources## can store several places for getting new mail 
for getting new mail. See Mail Source Specifiers (Gnus), which contains
a great section about this variable. In this tutorial, suffice it to
provide a template for POP users, that will deal with the lion's share
of the cases.

     (setq mail-sources '((pop :server "frumple" :user "jrl")))

Just replace "frumple" with the name of your POP server and jrl with your
login name on the POP server. This line goes in the file ~/.gnus.el. As
spefified above, Gnus will then ask for your password when you fetch
mail, but it gives you the choice of remembering the password for the
session. You can also put the password into ~/.gnus.el:

     (setq mail-sources '((pop :server "frumple"
                               :user "jrl"
                               :password "secret")))

Note that this means that your password is stored on your hard disk in
the clear! If you want to prevent this, you have to type the password
every time.

You can also have several entries for several servers, you only need to
be careful with the nesting of the parentheses:

     (setq mail-sources '((pop :server "frumple" :user "jrl")
                          (pop :server "mypop" :user "joe")))

For sending mail, you probably want to contact an SMTP server
directly. This is easily done with smtpmail.el. Just include the
following in ~/.gnus.el and replace host names and so on:

     (setq send-mail-function 'smtpmail-send-it) ; not for Gnus
     (setq message-send-mail-function 'smtpmail-send-it) ; for Gnus
     (setq smtpmail-default-smtp-server "YOUR SMTP HOST")
     (setq smtpmail-local-domain "YOUR DOMAIN NAME")
     (setq smtpmail-sendto-domain "YOUR DOMAIN NAME")
     (setq smtpmail-debug-info t) ; only to debug problems

The above was directly snarfed from the beginning of the file. The
comment there says it better than I ever could.

Of course, Gnus is almost infinitely customizable for sending mail,
too. Type C-h v message-send-mail-function <RET> for all the gory
details.


=== Auto-expire versus total-expire ===

Every now and then, people ask about auto-expire and total-expire. Since
both of these features are means to the same end, and since they are
similar and dissimilar at the same time, great confusion can result in
the unsuspecting new Gnus user. I'll try to explain how each works and
which one to use. However, be prepared that there will be no clear
recommendation: both work well, so for many situations both are
appropriate. So it is more a matter of taste which one to choose. And I
can't help you with that!


==== What is expiry? ====

Gnus treats mail in a newsreaderly fashion, so it is useful to examine
the situation for news. Your news server periodically contacts other
news servers and exchanges messages with the other server. The two news
servers exchange lists of messages, and messages present in one server
but not in the other are sent to the other server. This works in both
directions. Many connections between news servers exist, and this is the
way how postings travel from you into the world: when you post a
message, your news server stores it and offers it to the other servers
in the message list exchanging phase. Since the other servers aren't
going to have the posting you just wrote, it gets transferred and
finally can be seen all over the world.

You can quickly see that new messages will be arriving at your news
server, which stores them on disk. So something has got to happen else
the disk will fill up real fast. That ``something'' is expiry: the
oldest messages are deleted to make room for the new ones. Normally, a
news server can be configured on a per-group basis which messages should
be deleted. In some groups, messages might be deleted which are older
than a day, in other groups, messages might be kept for a month.

This means if you go on vacation then come back later to read news, you
are likely to miss some postings if the expiration time for the groups
you read is shorter than the time you were on vacation.

_How does that apply to mail?_

Well, mail should stay more under the control of the user than news
is. When you come back from a vacation, you expect to see all messages
arrived during that time, not only the recent ones!

Because of this, Gnus offers you the E key. This marks a message as
expirable. No mail is ever deleted from disk, unless it is
expirable. Every once in a while (by default, whenever you quit a group
by hitting q in the Summary buffer), the expiry process is run, which
goes through all expirable messages (of a group) and expires it if old
enough. By default, messages older than seven days are ``old
enough''. Seven days, that is, since it was marked as expirable.

FIXME: Last sentence correct?

``But when I read a message, exit the group, then enter it again, the
message is gone!''

Right. By default, Gnus hides messages which have already been read. If
you are the keyboard type, you can hit C-u <RET> or C-u <SPC> to enter
the group or C-u M-g when in the group to look at the read messages. If
you are the mousey type, you may wish to use the ``See old articles''
entry in the ``Group'' menu.

FIXME: How does one code menu entries in TeXinfo?


==== Why auto-expire and total-expire? ====

When reading mail, by default Gnus marks as read each message that you
read. If you want to mark it as expirable, you have to hit E. Many
people are subscribed to mailing lists and they configure Gnus to put
mails from a mailing list into their own group. Most messages in such
groups should be expirable, once read. But hitting E all the time gets
old real quick. Hence, auto-expire and total-expire were invented.


==== Auto-expire vs. total-expire ====

Auto-expire and total-expire both aim at the same goal: articles which
are read should normally be expired, only if one does something special
should these articles be saved on disk. But what happens when a message
is being read by you, the user? Well, the message is marked as read
(with the `R' mark). So, what can be done to make these messages expire?
Well, two approaches come to mind: one idea is to change the mark that
is attached to messages that you read, and the other idea is to make the
`R' articles expirable. These are exactly the things that are done in
Gnus: auto-expire means to change the mark that is attached to a message
that is being read, and total-expire means to change the meaning of the
`R' mark to mean expirable.

A more precise description of auto-expire might be the following: If an
article is unmarked and then selected for reading,1 it is marked with
`E', as if the user had hit E.

It is important to realize that auto-expire has no other
consequences. Selecting a message for reading which wasn't unmarked
doesn't do anything special, and hitting d on a message also doesn't do
anything special. (It therefore marks the message as read, not as
expirable!)

Now, forget about auto-expire, empty your mind and prepare to learn
about total-expire. Like I said, total-expire changes what it means for
an article to be marked as read.

A more precise description of total-expire might be the following: When
the expire process is run (for example, when you leave a group with q),
all messages marked as read are considered to be expirable, as if they
had been marked with `E'. Recall that there are several ways to mark a
message as read: by reading it, by hitting d on it, and in a few other
ways which I haven't mentioned so far. Recall that, in addition to the
messages marked with `R', also those marked with `r' or `O' are
considered to be marked as read.

Can auto-expire and total-expire be used together? Well, in principle
they can, but that doesn't make sense. Just using total-expire alone
achieves the same effect.

So, how do auto-expire and total-expire compare? Well, for once thing,
hitting d on a message means it is expirable if total-expire is on
(since it is marked as read and all messages marked as read are
considered expirable when total-expire is on), but it is not expirable
if auto-expire is on (since it is marked as read and only articles
marked expirable (`E') are considered to be expirable). If you want to
mark a message as expirable when total-expire is off, use E.

One way of comparing auto-expire and total-expire is to compare the
message marks that are available, and what they mean. Since auto-expire
does not change the meaning of marks, its behavior is the same as in the
default case. It's only important whether total-expire is on or
off. Thus, there are only two cases: the default case and the
total-expire case.


===== Article marks with and without total-expire =====

The following are the default article marks and behavior:

_unmarked_

All new messages are unmarked. This means you haven't seen them. They
are always shown and won't be deleted.

_read_

Messages marked as read are not shown by default but kept on disk till
hell freezes over. You can show them with C-u M-g from the summary
buffer, or with C-u <SPC> or with the `Group' menu item `See old
articles' from the group buffer.

Depending on the setting of gnus-fetch-old-headers, a message marked as
read might be shown if there is a followup or reply to it.

_dormant_

Dormant messages aren't shown by default but kept on disk till hell
freezes over. You can show them with / D from the summary buffer. If
there is a reply or followup to a dormant message, the dormant message
is also shown.

_ticked_

Ticked messages are always shown and kept on disk till hell freezes
over.

_expirable_

Expirable messages will be deleted in due time. They are not shown by
default, but you can make them appear with C-u M-g and so on, similar to
the read ones.

Please note that the behavior for ticked messages is similar to the
unread ones, and that the behavior of dormant messages is similar to the
read ones. Especially the second fact will become important when we look
_at_

The behavior of the article marks with total-expire:

_unmarked_

Same as in the default case.

_expirable_

Same as in the default case.

_read_

Same as expirable.

_dormant_

Same as in the default case.

_ticked_

Same as in the default case.

As you can see, only the behavior of the read messages is different, and
you can use the dormant mark if you want to achieve behavior similar to
the behavior of read messages in the default case.


===== Speed issues =====

Total-expire may be slow when expiry happens. Why is that? Well, Gnus
keeps an explicit list of all expirable messages (the ones marked `E'
without taking total-expire into account), as well as a list of dormant
messages, and a list of ticked messages. Normally, when expiration time
comes, Gnus goes through all articles in the expire list and looks if
they are old enough to be expired.

However, for read messages the situation is different. Here, Gnus just
keeps a list of ranges of article numbers to be able to distinguish read
messages from unmarked ones. The assumption is that a message is to be
considered marked as read if it falls in one of the ranges and isn't
mentioned in any of the expirable, dormant or ticked lists.

When total-expire is turned on, Gnus needs to go through all messages in
the read range in order to look if it's in one of the lists. If the
message is not in the ticked or dormant list, it is expirable and thus
Gnus looks to see if it is old enough.

Obviously, going through all the articles in the read ranges takes more
time than going through just the list of expirable articles.

Something can be done about the speed issue, though. Normally, the
expiry process is started whenever you leave a group. I suggest that you
disable this and instead run expiry just once per day, for example while
you are going for lunch. This means that expiry still takes a long time,
but you don't see it and thus it doesn't bother you.

Here's how to do that: You disable the expire-on-group-exit thing with
the following line in your ~/.gnus.el file:

     (remove-hook 'gnus-summary-prepare-exit-hook

                  'gnus-summary-expire-articles)

And before you leave for lunch, you hit C-c C-M-x, or M-x
gnus-group-expire-all-groups <RET>.


===== Functionality =====

Adaptive scoring doesn't work with auto-expire. (But normal scoring
still works fine.) Adaptive scoring works fine with total-expire.


===== A summary =====

Well, it is difficult to sum up the whole discussion. I used to use
total-expire but have switched to auto-expire a long time ago. I liked
the fact that I could use one more kind of article mark. I also liked
the fact that marking a message as read works the same in auto-expirable
groups and in normal mail groups: you hit E. (With total-expire, you
normally hit d but must remember to use E for those groups where
total-expire is off.) And I liked that auto-expire is faster.

On the other hand, adaptive scoring is surely a very useful feature (I'm
just beginning to use it), so many people might prefer total-expire.

And on a third hand, maybe the key binding issue isn't so important
after all. You see, in mail groups the d key means `keep this message
for archival purposes', whereas in many other modes (dired, FIXME:
others?) it stands for `delete'. I propose to make it mean delete in
mail groups, too, with the following line in ~/.gnus.el:2

     (define-key gnus-summary-mode-map "d"
     'gnus-summary-mark-as-expirable)

Marking messages as expirable (rather than read) in news groups does no
harm, nor does it harm to do so in total-expirable mail groups. The old
`keep this message' semantics can still be had by marking a message as
dormant or by using M r (in non-total-expirable groups only).


=== Migrating old mail ===

Probably, you've been reading mail in pre-Gnus times, right? And surely
you wish to carry this over to Gnus. Well, I haven't found a real good
way to do it, but I can offer a few suggestions for doing it at least
semi-automatically.

One way of getting at your old mail is to type G f, and to then enter
the name of your old mail file. This provides read-only access to your
mails. For some people, this might be sufficient. (With G f, you have
created an nndoc group.)

Some people might want to have their mails available in their normal
mail groups hierarchy. That's simple, just create an nndoc group for
your mail file, then mark all messages in it with M P a, then copy all
of them over to a normal mail group, with B c.

This is good for people who wish to keep their old arrangement of
folders, and who have a one-to-one correspondence between old mail files
and new Gnus groups. But some people might wish to split up their mails
differently. For them, it might be useful to set up nnmail-split-methods
correctly and to use B r instead of B c. This goes through all
process-marked messages and subjects them to the same splitting process
that newly arriving messages go through. (Whee! What a run-on sentence!)


=== Making Gnus behave like other mail readers ===

FIXME: This section is very incomplete! I hope that somebody will
provide us with settings that might be desirable.


==== Don't hide messages that have been read ====

Gnus operates in a newsreaderly fashion and thinks that most of the time
you don't want to read messages twice. So it hides from you the messages
that you have read already. It does not, however, delete these messages!
They are still on disk.

If you want to see old messages, use C-u <RET> to enter a group, or type
C-u M-g from within the group. If you always want to see old messages
for a specific group, hit G c (not g c) on it and frob the display
parameter. If you want to see old messages for several groups, you can
also set the parameter on a topic. If you want to do it by group name,
see the variable gnus-parameters (in recent Gnusae only).

But I advise against this, because showing a lot of messages in the
summary buffer is quite slow in Gnus, and you can tell Gnus to show you
the interesting ones. For example, I use

     (setq gnus-fetch-old-headers t)

and this means that when a new followup arrives in a thread, I see the
previous messages from that thread, too. Of course, from time to time, I
want to look at old messages and use C-u <RET> or C-u M-g, as described
above. (Be aware that putting fetch-old-headers to t will take an long time to download
[http://www.emacswiki.org/emacs/ColinBaxter ColinBaxter])

==== Marking messages read on the server with nnimap ====

When reading mail from several different clients (a home and work computer, for example),
it can be nice to have read mail marked as read on the server, so that the messages
appear read when reading from another client.

FIXME: Does anyone know how to do this?

=== Archiving Mail ===

(TODO)

_Footnotes_

[1] Using g, or <mouse-2>, or by moving to it with n or p, or by one of
the many other methods provided by Gnus.

[2] See the chapter on key bindings; maybe you need a `require'
statement.

== Multiple Mailboxes (using multiple From: headers) ==
{{{
(setq my-email-addresses '("user@gmail.com"
			   "user@domain.net"
                           "user@work.com"
                           "user@isp.com"
			   "user@communitygroup.org"))
(setq message-alternative-emails
      (regexp-opt my-email-addresses))

;; Gnus from manipulation
(setq gnus-from-selected-index 0)
(defun gnus-loop-from ()
  (interactive)
  (setq gnus-article-current-point (point))
  (goto-char (point-min))
  (if (eq gnus-from-selected-index (length my-email-addresses))
      (setq gnus-from-selected-index 0) nil)
  (while (re-search-forward "^From:.*$" nil t)
    (replace-match (concat "From: " user-full-name " <" (nth gnus-from-selected-index my-email-addresses) ">")))
  (goto-char gnus-article-current-point)
  (setq gnus-from-selected-index (+ gnus-from-selected-index 1)))

(global-set-key (kbd "C-c f") 'gnus-loop-from)
}}}

I've made what is for me a slightly more useful version of this:

{{{
(setq my-email-addresses '(...))

(defun bsb/loop-from ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward
           "^From: *\\([^<\n]*?\\) *\\(<\\([^>\n]*\\)>\\)?$" nil t)
      (let* ((no-name (null (match-string 2)))
             (name (if no-name user-full-name (match-string 1)))
             (address (match-string (if no-name 1 3))))
        (replace-match (concat "From: " name
                               " <" (bsb/next-address address) ">"))))))

(defun bsb/next-address (address)
  (let ((found (member address bsb/email-addresses)))
    (if found
        (if (cdr found)
            (cadr found)
          (car bsb/email-addresses))
      (if (eq last-command this-command)
          (setq bsb/from-selected-index
                (mod (+ bsb/from-selected-index 1) (length bsb/email-addresses)))
        (setq bsb/from-selected-index 0))
      (nth bsb/from-selected-index bsb/email-addresses))))
}}}

This replaces an address with the next one in the list rather than starting from the first.  Of course, if the From: line does not have a recognised address it just behaves as before.  Also it preserves any friendly name that
might be on the line and the save-excursion prevents the point from jumping about as the address length changes.

== Reading articles ==

If you are new to Gnus, the amount of keybindings can be daunting. This section goes over the minimum required to get started using Gnus.

Note that this stuff pertains to both news *and* mail reading, which is
one of the best things about Gnus: it provides you with a powerful and
*unified* set of commands.

=== Moving Around ===

(This section focuses only on the ##group## and ##summary## buffers)

See ##C-h m## for a list of commands. Here are the most common ones.

|| Key || Group Buffer                        || Summary Buffer          || 
|| n   || Next group with *unread* articles   || Next unread article     ||
|| p   || Previous group with unread articles || Previous unread article ||
|| N   || Next group                          || Next article            ||
|| P   || Previous group                      || Previous article        ||
|| C-n || Next line                           || Next line               ||
|| C-p || Previous line                       || Previous line           ||

Most of the time, you only want to select *new* articles that you haven't yet read, 
so *jumping to new articles* is prioritized, though accessing old / read articles is still easy.

If you reach the bottom of a summary buffer and press ##n##, Gnus will load the first unread article for the next group (So you can use one hand to press ##n##, and the other to hold a cup of tea).

##C-n## and ##C-p## are *never* rebound. They are the same in every Emacs mode.

You can scroll an individual article with ##SPC## and ##DEL##. This is much preferable to switching windows (##C-x o##) and scrolling (##C-v##, ##M-v##) through them :3

== External Links ==
* [http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/gnus/gnus.el gnus.el] -- The latest upstream version of Gnus
** To find the latest version number, search for ##defconst gnus-version-number## (may be in Beta)

----

CategoryGnus
