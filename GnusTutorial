This is a step-by-step guide to using [[Gnus]], an Emacs package for reading [b]Netnews[/b],
 [b][GettingMail email][/b], *RSS*, and much more. It is highly customizable.

However, all this can make it hard to learn. The [[https://www.gnu.org/software/emacs/manual/html_mono/gnus.html Gnus Manual]] 
is more of a *technical reference* than a user
guide, so new users often find it difficult to understand.


== Fundamental Configuration ==

Before using Gnus, you must tell it about you. Open (or create) ##~/.gnus.el## and enter:

{{{
(setq user-mail-address  "you@domain.com"
      user-full-name     "Your Full Name"
      mail-signature     "Most pettable Dog")

;; Instead, you may set the $EMAIL and $NAME environment variables.
}}}

Gnus needs to know where to *fetch* its messages from. In this example we specify multiple sources:

* ##foo.bar.com## -- An NNTP server.
* ##localhost## -- Our local news spool.
* ##mail.example.com## -- Our Email provider.

{{{
(setq
  gnus-select-method            '(nntp     "foo.bar.com")
  gnus-secondary-select-methods '((nnspool "localhost")
                                  (nnml    "")))

(setq mail-sources
      '((pop :server   "mail.example.com"
             :user     "Laura"
             :password "passw0rd")))
}}}

If required, Gnus will prompt for a *username* and *password* every time. To avoid this, put the following in ##~/.authinfo##

{{{
machine foo.bar.com login your_username  passwerd your_pass
machine localhost   login your_username2 password your_pass2 force yes
    
# "force yes" forces a username connection over anonymous.
}}}

Gnus needs to know how to *send* mail. ##smtpmail## is easy as it comes built-into Emacs.
Add the following lines to ##~/.gnus.el##:

{{{
(setq send-mail-function		'smtpmail-send-it
      message-send-mail-function	'smtpmail-send-it
      smtpmail-smtp-server		"mail.example.com")

;; Instead of smtpmail-smtp-server, you may set the environment variable $SMTPSERVER
}}}

Emacs' default SMTP port is [b]25[/b]. To change this, customize ##smtpmail-smtp-service##.

If your *SMTP server* requires authentication, please read 
[[http://www.gnu.org/software/emacs/manual/html_node/smtpmail/Authentication.html#Authentication This Manual page]].

== Using Gnus ==

Start Gnus with ##M-x gnus##.

Gnus will open the servers in your *select methods* and fetch *new messages*, then open the *Group buffer* where your Groups are listed.

Use ##A A## to list available groups. ##u## *subscribes* you to the selected group.

Here's an overview of common commands:

* `RET' -- Enter the group under the point
* `g' -- Check for news nd mail.
* `q' -- Quit Gnus (Always close Gnus before closing Emacs)
* `c' -- Catchup (marks all articles as read)
* <code>‘#’</code> -- Mark a group
* `l' -- Show only groups with unread articles
* `L' --Show all subscribed groups
* `m' -- Compose new Mail
* `a' -- Create a new Post
* `V' -- Display current Gnus version number.
* <code>‘^’</code> -- Enter server buffer

=== Topics ===

You may *sort* groups into "folders". Gnus calls these folders *topics*.
Hit ##t## to enter ##topic-mode##.  There are two *default* topics -- ##gnus## and ##misc##.
To make a new topic, place the cursor over a topic, and say ##T n##.

Move a group to a new Topic by saying ##T m## over the group you want to move.

If you want ##topic-mode## to be *always active*, place the following in your
##~/.gnus.el##:

{{{
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
}}}

=== Summary Buffer ===

When you *enter* a group, Gnus will fetch *headers* for that group. When it has finished, it will open a buffer showing a *summary* of each article in the group. Select an article with ##<RET>## and scroll through it with ##<SPC>## and ##<DEL>##.

To change how the Summary *looks*, customize [[https://gnus.org/manual/gnus_31.html gnus-summary-line-format]]. For example:

{{{
(setq gnus-summary-line-format "%U%R%z %d  %-30n  %B%s\n")
}}}

Here are some common keybindings:

* `C-h m' -- View all keybindings
* `RET' -- View article under point
* `n' -- Next new article
* `p' -- Previous article
* `SPC' -- Scroll down / Next article
* `DEL' -- Scroll up
* `F' -- Reply to *news* thread and quote the article.
* `R' -- Reply to *mail* and quote the sender
* `m' -- New mail
* `a' -- New Post
* `c' -- Catchup (fetch new articles)
* `C-u / t' -- Show only new posts.
* `t' -- Toggle post headers.
* `W w' -- Word-wrap the current post.
* `L' -- Create a *score entry* (##?## for help)

=== Composing Mail ===

When you use a *Compose* key (say, ##m##), you'll enter a new buffer.
Fill out the ##Subject:## header and enter your post body below ##--text follows this line--##. You may add additional headers above this line (e.g. ##X-Drunk-as-a-lord: yes##).

You likely want automatic word-wrapping. Add the following
lines in ##~/.gnus##:

{{{
(defun my-message-mode-setup ()
  (setq fill-column 72)
  (turn-on-auto-fill))

(add-hook 'message-mode-hook 'my-message-mode-setup)
}}}

Commands for composing mail:

* ##C-c C-c## -- Send message
* ##C-c C-d## -- Save message as draft
* ##C-c C-k## -- Kill message
* ##C-c C-m f## -- Attach file
* ##M-q## -- Reformat paragraph
* ##M-x message-caesar-region## -- encode region using ROT13

=== Help! ===

Soon enough (after about 17 seconds of
using Gnus), you'll find yourself in a situation where you have no idea
how to do something. Here are some ways to search for solutions:

* ##C-h i d m gnus## -- Read the Gnus Manual (Press ##s## to search).
* ##C-h ?## -- Displays the system help menu.
* ##C-h m## -- Displays the current mode's keybindings.
* ##C-h b## -- Displays all Emacs keybindings.
* The Menu Bar -- Common Gnus functions are sometimes kept here.

If you're really stuck, you can ask other Gnusers. Proper places for this are:

* gnu.emacs.gnus
* news.software.readers
* gnus.ding -- (If you're on an Alpha release)

=== Miscellaneous ===

* When Gnus asks you for an input, it is likely *tab-completable*.
* Gnus buffers are also *normal Emacs buffers*; You can use all Emacs commands from Gnus.

== Basic terminology and news reading ==

Terms I use which might be unfamiliar to you.

_say_ -- "You can *say* ##(setq my-var t)## to enable ##my-var##

_Posting, Article, Message, Mail_

All similar. I use the term *message* to refer to both email /and/ news posts,
but *mail message* and *news message* for the individual cases. "posting" and "article"
are synonymous with "message.

_Backend_

Gnus fetches messages from various sources. A *backend* describes how Gnus
*accesses* a set of messages from a server. Gnus uses the ##nntp## backend to interface with NNTP servers, and the ##nnimap## backend to talk to IMAP servers.

_Server_

Whereas a backend describes the mechanism used by Gnus to access the
messages, a server is a specific instance of that mechanism. You might
create a specific server for accessing the host news.frob.org using
NNTP, say. Or you might create a server for accessing the MH-style
directory ~/OldMail.

If you are a programmer, think of a backend as the class and of a server
as an object (instance) of that class. If you are a cook, think of a
backend as an apple pie recipe (say), and think of a server as an actual
apple pie. (Yummy!) If you live in a huge city, think of a backend as a
bus (or tram, or underground) line (the Circle Line comes to mind), and
think of a server as a specific bus (or tram train, or underground
train). The one at 8:15 last Monday morning, for example. If you drive a
car, think of a backend as the model and make and of a server as a
specific car.

Obviously, there can be two servers using the same backend. (Two
instances of the same class, two apple pies baked according to the same
recipe, two busses going the same route, two cars of the same model.)

[u](Select) method[/u]

Just another term for server.

[u]Native server[/u]

This is the *primary server*, so to speak. Most people let their news
server be the native server, hence:

          (setq gnus-select-method '(nntp "news.frob.org"))

_Secondary select methods_

A list of additional servers one wishes to use. 

Groups from a secondary server are known as *secondary groups*.

In order to be able to distinguish native groups from secondary groups,
each server is identified with a (unique) name and that name is used as
a prefix for the secondary groups. Thus, you might have a group
gnu.emacs.help (which is native) and another group nnml:mail.misc (which
is secondary). A plus character is used if the name of a server is not
the empty string. For example, given the following in your ~/.gnus.el
file

          (setq gnus-secondary-select-methods
                '((nnml "work" (nnml-directory "~/Mail.work/"))
                  (nnml "play" (nnml-directory "~/Mail.play/"))))

you might have the groups ##nnml+work:boss## and ##nnml+play:so1##.

_Group_

Well, if you've read news before, you know about different news
groups. One of my favorites is gnu.emacs.gnus, and I wish I would read
alt.fan.pratchett. Since Gnus treats mail in a newsreaderly fashion, it
is obvious that it uses groups rather than ``folders'' like other mail
readers do. So with Gnus there are news groups and mail groups, where
mail groups are known as mail folders to other programs.

Each group belongs to a certain server, and each server uses a certain
backend.

_Expiry_

News servers offer news groups which contain news postings. New news
postings come in, so the news postings accumulate, and pretty soon the
new hard disk is full. This is not good news at all.

Thus, a news server does what is known as expiry: it deletes old
messages. Of course, on a news server, expiry happens with no regard of
whether people have already seen the message in question; instead, the
news server admin chooses expiry times based on available disk space and
maybe on the normal amount of traffic in a news group.

But mail messages should be under the users' control, so there better be
no server which deletes messages regardless of users having seen them!
Instead, Gnus adopts a scheme where users say which messages may be
deleted, and Gnus takes care of deleting them after a while. (They are
not deleted immediately in case you made a mistake, or in case you wish
to refer back to an old article.)

_Article marks_

Gnus distinguishes between a number of article marks, which indicate
whether they have been looked at, or are considered important, or the
like. Marks are represented by a character.

If that character is a space, it looks as if the message isn't marked at
all. These messages are called unmarked, the mark character used is a
space, and marking a message with space is considered to be the same as
removing all marks—after all, such messages are unmarked. You can type
M-u to remove all marks and make an article unmarked.

Articles that are considered important or where you wish to indicate
that you have to deal with them later can be ticked. The mark character
used for ticked messages is the exclamation mark, and you can use u or !
to tick messages. Ticked messages are always shown when you enter a
group.

There is the dormant mark which is similar to the ticked mark but does
not imply importance or urgency; thus, dormant messages aren't shown by
default. The mark character used is the question mark, and you can mark
messages as dormant using the ? key.

So far, each kind of mark was associated with one character (as was the
absence of any mark). But articles which you have read are a bit
different, since lots of different characters are used here. The
important thing to realize is that these messages are treated in the
same way by Gnus; the different characters are only used as an
information for the user.

Articles which are marked as read because you have actually read them
(the normal case, one would think) are marked with the `R'
character. (Type <SPC> or g to read a message, or click on it using the
middle mouse button, <mouse-2>.) You can also mark a message as read
without actually reading it, this is indicated with the `r' character
and can be achieved with d or M r.

After exiting a group and then entering it again (some time later), the
messages that had been marked as read before appear with the `O'
character.

To reiterate: the difference between `r', `R' and `O' is only an
information for the user.

_Footnotes_

[1] ``SO'' standing for ``significant other'', i.e. girlfriend or
boyfriend.


== Mail ==

Gnus is primarily a news reader, but *this is a good thing*, as it turns
out "managing email in a very newsreaderly fashion" is very efficient.

It would be an uphill battle if you tried to make Gnus "behave like a /normal/
email client". Instead of telling Gnus to change, let Gnus change /you/.

You need to tell Gnus:

* How to *store* mail on the local disk.
* *Where* to get the mail messages.
* How to *send* new mail.

The difference between mail *backends* and mail *sources* is that a backend tells
Gnus how to store messages, whereas mail sources specify where to fetch them. Gnus fetches 
mail from the source, and stores it in the backend. Sources are stored in ##mail-sources##. Backends are
stored in ##gnus-secondary-select-methods##.

The ##nnimap## backend is an exception: the IMAP server itself
stores your mail; it doesn't need to be fetched.

=== Backends ===

The Gnus manual lists many backends. For news, theres:

* ##nntp## -- Access an NNTP Netnews server.
* ##nnspool## -- If you have a local news spool
** (Leafnode users should always use ##nntp##)

There are many mail backends. This list has more popular choices near the top:

* ##nnmaildir## -- Stores messages in files in a folder
* ##nnimap## -- Manages mail on server. Good if you use multiple devices.
* ##nnmbox## -- Stores messages all in one ##~/mbox## file.
* ##nnfolder## -- Uses the ##mbox## format, but uses separate files.
* ##nnml## -- Generates an "overview" file to make parsing fast.
* ##nnmh## -- The MH format where file names are numbered.
* ##nnbabyl## -- Like ##mbox## but with delimiters for message start/ends.

See MailFiles for a more complete analysis.

==== Hands-on Advice ====

You can choose a server name by adding text to the server string:

     (add-to-list 'gnus-secondary-select-methods '(nnml "x")) ; nnml+x:foo
     (add-to-list 'gnus-secondary-select-methods '(nnml ""))  ; nnml:foo

This is useful when you have multiple ##nnml## inboxes.

Each server has a set of optional *server parameters*. For example, if you use
the ##nnmbox## backend, then you can specify a different mbox file
to use (the default is ##~/mbox##):

     (add-to-list 'gnus-secondary-select-methods
                  '(nnmbox ""
                    (nnmbox-mbox-file "~/MAIL")
                    (nnmbox-active-file "~/Mail.active")))

See the [[https://gnus.org/manual/gnus_84.html#Unix-Mail-Box Gnus mbox page]] for more parameters.

Each server wants to *own* the
directories and files it writes to, and gets very angry if it finds that
they are already occupied. Therefore, the ##nnchoke-frumple-file## and the
##nnchoke-gargle-directory## parameters are pretty important. For example,
if you have used Pine before Gnus, then you are going to have a ##~/Mail/##
directory which is used by Pine. Therefore, you should add the right
parameters to tell Gnus to stay away from that directory. For example:

     (add-to-list 'gnus-secondary-select-methods
                  '(nnml ""
                    (nnml-directory "~/GnusMail/")
                    (nnml-active-file "~/GnusMail/active")))

The file-per-message and file-per-group types of backends each have a
parameter nnchoke-directory, the file-per-server type of backend has a
nnchoke-mbox-file parameter. All these backends have a
nnchoke-active-file parameter.

=== Fetching and Sending ===

The previous section has explained how Gnus fetches mail to read.
But the question is, how does the mail actually get to
your local disk in the first place? For many people, the answer is
*POP* ([b]P[/b]ost [b]O[/b]ffice [b]P[/b]rotocol). Gnus can connect
to a POP server, which is a remote location holding your mail.

##mail-sources## can store several places for getting new mail 
for getting new mail. See Mail Source Specifiers (Gnus), which contains
a great section about this variable. In this tutorial, suffice it to
provide a template for POP users, that will deal with the lion's share
of the cases.

     (setq mail-sources '((pop :server "mail.example.com"
                               :user   "jrl@example.com"
                               :password "passw0rd")))

Without ##:password##, Gnus will ask for your password every time.

You can also have several servers:

     (setq mail-sources '((pop :server "mail1.example.com" :user "jrl")
                          (pop :server "serv2.example.com" :user "joe")))

For *sending* mail, you'll likely use SMTP:

     (setq send-mail-function 'smtpmail-send-it)             ; Not for Gnus
     (setq message-send-mail-function 'smtpmail-send-it)     ; For Gnus
     (setq smtpmail-default-smtp-server "mail.example.com")  ; SMTP server that you'll send from.
     (setq smtpmail-debug-info t)                            ; only to debug problems

Say ##C-h v message-send-mail-function## for more details on sending mail.

== Expiry ==

Gnus' way of "deleting" mail is called *Expiry*. Mark a message as expirable with ##E##. It will be deleted after [b]1 week[/b].

You may also tell Gnus to *automatically* expire mail after reading them:

* Total Expire -- Treat *all* mail marked "as read" as expirable.
* Auto Expire -- Mark mail as expirable on-read (can be unmarked manually)

{{{
;; These variables take a regexp input.
(setq gnus-auto-expirable-newsgroups  "nnmbox:mail.misc"
      gnus-total-expirable-newsgroups "nnml:mail.misc")
}}}

==== Marks ====

The following are the default article marks and behavior:

* _unmarked_ -- All new messages are unmarked.
* _read_ -- Not shown on disk by default, but kept unless expirable.
** ##C-u M-g## shows all read mail.
* _dormant_ -- Not shown by default. Shew them with ##/ D##
* _ticked_ -- Ticked messages are always shown and can't expire.
* _expirable_ -- Will be deleted automatically over time.

==== Speed Issues ====

Auto-expire is usually *faster* than Total-expire.

Gnus keeps a list of:

* All *expirable* messages,
* All *dormant* messages,
* All *ticked* messages. 

During expiration time, Gnus scans the expire list to see which entry is old enough to delete.

For *read* messages, Gnus keeps 2 lists: One for

However, for *read* messages the situation is different. Here, Gnus just
keeps a list of ranges of article numbers to be able to distinguish read
messages from unmarked ones. The assumption is that a message is to be
considered marked as read if it falls in one of the ranges and isn't
mentioned in any of the expirable, dormant or ticked lists.

When *total-expire* is on, Gnus needs to make sure every *read* message isn't
ticked or dormant first, before confirming it's expirable.

Checking each article in the "read" range takes more
time than just going through the list of expirable articles.

You may opt to simply run expiry manual on your own when you feel like it. 
In that case, you can tell Gnus to no longer expire on quit:

{{{
(remove-hook 'gnus-summary-prepare-exit-hook
             'gnus-summary-expire-articles)
}}}

Then run ##gnus-groups-expire-all-groups## with ##C-c C-M-x##.

: Normal scoring works with *auto-expire*, but not *Adaptive scoring*. Adaptive scoring works with total-expire.


=== Migrating old mail ===

Probably, you've been reading mail in pre-Gnus times, right? And surely
you wish to carry this over to Gnus. Well, I haven't found a real good
way to do it, but I can offer a few suggestions for doing it at least
semi-automatically.

One way of getting at your old mail is to type G f, and to then enter
the name of your old mail file. This provides read-only access to your
mails. For some people, this might be sufficient. (With G f, you have
created an nndoc group.)

Some people might want to have their mails available in their normal
mail groups hierarchy. That's simple, just create an nndoc group for
your mail file, then mark all messages in it with M P a, then copy all
of them over to a normal mail group, with B c.

This is good for people who wish to keep their old arrangement of
folders, and who have a one-to-one correspondence between old mail files
and new Gnus groups. But some people might wish to split up their mails
differently. For them, it might be useful to set up nnmail-split-methods
correctly and to use B r instead of B c. This goes through all
process-marked messages and subjects them to the same splitting process
that newly arriving messages go through. (Whee! What a run-on sentence!)


=== Making Gnus behave like other mail readers ===

FIXME: This section is very incomplete! I hope that somebody will
provide us with settings that might be desirable.


==== Don't hide messages that have been read ====

Gnus operates in a newsreaderly fashion and thinks that most of the time
you don't want to read messages twice. So it hides from you the messages
that you have read already. It does not, however, delete these messages!
They are still on disk.

If you want to see old messages, use C-u <RET> to enter a group, or type
C-u M-g from within the group. If you always want to see old messages
for a specific group, hit G c (not g c) on it and frob the display
parameter. If you want to see old messages for several groups, you can
also set the parameter on a topic. If you want to do it by group name,
see the variable gnus-parameters (in recent Gnusae only).

But I advise against this, because showing a lot of messages in the
summary buffer is quite slow in Gnus, and you can tell Gnus to show you
the interesting ones. For example, I use

     (setq gnus-fetch-old-headers t)

and this means that when a new followup arrives in a thread, I see the
previous messages from that thread, too. Of course, from time to time, I
want to look at old messages and use C-u <RET> or C-u M-g, as described
above. (Be aware that putting fetch-old-headers to t will take an long time to download
[http://www.emacswiki.org/emacs/ColinBaxter ColinBaxter])

==== Marking messages read on the server with nnimap ====

When reading mail from several different clients (a home and work computer, for example),
it can be nice to have read mail marked as read on the server, so that the messages
appear read when reading from another client.

FIXME: Does anyone know how to do this?

=== Archiving Mail ===

(TODO)

_Footnotes_

[1] Using g, or <mouse-2>, or by moving to it with n or p, or by one of
the many other methods provided by Gnus.

[2] See the chapter on key bindings; maybe you need a `require'
statement.

== Multiple Mailboxes (using multiple From: headers) ==
{{{
(setq my-email-addresses '("user@gmail.com"
			   "user@domain.net"
                           "user@work.com"
                           "user@isp.com"
			   "user@communitygroup.org"))
(setq message-alternative-emails
      (regexp-opt my-email-addresses))

;; Gnus from manipulation
(setq gnus-from-selected-index 0)
(defun gnus-loop-from ()
  (interactive)
  (setq gnus-article-current-point (point))
  (goto-char (point-min))
  (if (eq gnus-from-selected-index (length my-email-addresses))
      (setq gnus-from-selected-index 0) nil)
  (while (re-search-forward "^From:.*$" nil t)
    (replace-match (concat "From: " user-full-name " <" (nth gnus-from-selected-index my-email-addresses) ">")))
  (goto-char gnus-article-current-point)
  (setq gnus-from-selected-index (+ gnus-from-selected-index 1)))

(global-set-key (kbd "C-c f") 'gnus-loop-from)
}}}

I've made what is for me a slightly more useful version of this:

{{{
(setq my-email-addresses '(...))

(defun bsb/loop-from ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward
           "^From: *\\([^<\n]*?\\) *\\(<\\([^>\n]*\\)>\\)?$" nil t)
      (let* ((no-name (null (match-string 2)))
             (name (if no-name user-full-name (match-string 1)))
             (address (match-string (if no-name 1 3))))
        (replace-match (concat "From: " name
                               " <" (bsb/next-address address) ">"))))))

(defun bsb/next-address (address)
  (let ((found (member address bsb/email-addresses)))
    (if found
        (if (cdr found)
            (cadr found)
          (car bsb/email-addresses))
      (if (eq last-command this-command)
          (setq bsb/from-selected-index
                (mod (+ bsb/from-selected-index 1) (length bsb/email-addresses)))
        (setq bsb/from-selected-index 0))
      (nth bsb/from-selected-index bsb/email-addresses))))
}}}

This replaces an address with the next one in the list rather than starting from the first.  Of course, if the From: line does not have a recognised address it just behaves as before.  Also it preserves any friendly name that
might be on the line and the save-excursion prevents the point from jumping about as the address length changes.

== Reading articles ==

If you are new to Gnus, the amount of keybindings can be daunting. This section goes over the minimum required to get started using Gnus.

Note that this stuff pertains to both news *and* mail reading, which is
one of the best things about Gnus: it provides you with a powerful and
*unified* set of commands.

=== Moving Around ===

(This section focuses only on the ##group## and ##summary## buffers)

See ##C-h m## for a list of commands. Here are the most common ones.

|| Key || Group Buffer                        || Summary Buffer          || 
|| n   || Next group with *unread* articles   || Next unread article     ||
|| p   || Previous group with unread articles || Previous unread article ||
|| N   || Next group                          || Next article            ||
|| P   || Previous group                      || Previous article        ||
|| C-n || Next line                           || Next line               ||
|| C-p || Previous line                       || Previous line           ||

Most of the time, you only want to select *new* articles that you haven't yet read, 
so *jumping to new articles* is prioritized, though accessing old / read articles is still easy.

If you reach the bottom of a summary buffer and press ##n##, Gnus will load the first unread article for the next group (So you can use one hand to press ##n##, and the other to hold a cup of tea).

##C-n## and ##C-p## are *never* rebound. They are the same in every Emacs mode.

You can scroll an individual article with ##SPC## and ##DEL##. This is much preferable to switching windows (##C-x o##) and scrolling (##C-v##, ##M-v##) through them :3

== External Links ==
* [http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/gnus/gnus.el gnus.el] -- The latest upstream version of Gnus
** To find the latest version number, search for ##defconst gnus-version-number## (may be in Beta)

----

CategoryGnus
