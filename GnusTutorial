This is a step-by-step guide to using [[Gnus]], an Emacs package for reading [b]Netnews[/b],
 [b][GettingMail email][/b], *RSS*, and much more. It is highly customizable.

== Setup ==

Gnus needs to know some details first. In ##~/.gnus.el##, write:

{{{
;; As shown on the 'From:' header.
(setq user-mail-address  "laura@example.com"  ; $EMAIL
      user-full-name     "Laura Smith")       ; $NAME

;; Primary server and two additional servers.
(setq
  gnus-select-method '(nntp "foo.bar.com")
  gnus-secondary-select-methods '((nnspool "localhost")
                                  (nnml    "")))

;; 'nnml' looks here for credentials
(setq mail-sources
      '((pop :server   "mail.example.com"   
             :user     "Laura@example.com"
             :password "passw0rd")))

;; SMTP -- for sending mail.
(setq 
  send-mail-function   'smtpmail-send-it
  smtpmail-smtp-server "mail.example.com" ; $SMTPSERVER
  smtpmail-smtp-service 587)
}}}

To avoid a username and password prompt every time, add this to ##~/.authinfo##

{{{
machine mail.example.com login laura@example.com password passw0rd port 993
machine mail.example.com login laura@example.com password passw0rd port 587 force yes 
    
# 'force yes' forces a username connection over anonymous.
}}}

== General Usage ==

Start Gnus with ##M-x gnus##.

Gnus will open the servers in your *select methods* and fetch *new messages*, then open the *Group buffer* where your Groups are listed.

Use ##A A## to list available groups. ##u## *subscribes* you to the selected group.

Here's an overview of common commands:

* `RET' -- Enter the group under the point
* `g' -- Check for news nd mail.
* `q' -- Quit Gnus (Always close Gnus before closing Emacs)
* `c' -- Catchup (marks all articles as read)
* <code>‘#’</code> -- Mark a group
* `l' -- Show only groups with unread articles
* `L' --Show all subscribed groups
* `m' -- Compose new Mail
* `a' -- Create a new Post
* `V' -- Display current Gnus version number.
* <code>‘^’</code> -- Enter server buffer

=== Topics ===

You may *sort* groups into "folders". Gnus calls these folders *topics*.
Hit ##t## to enter ##topic-mode##.  There are two *default* topics -- ##gnus## and ##misc##.
To make a new topic, place the cursor over a topic, and say ##T n##.

Move a group to a new Topic by saying ##T m## over the group you want to move.

If you want ##topic-mode## to be *always active*, place the following in your
##~/.gnus.el##:

{{{
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
}}}

=== Summary Buffer ===

When you *enter* a group, Gnus will fetch *headers* for that group. When it has finished, it will open a buffer showing a *summary* of each article in the group. Select an article with ##<RET>## and scroll through it with ##<SPC>## and ##<DEL>##.

To change how the Summary *looks*, customize [[https://gnus.org/manual/gnus_31.html gnus-summary-line-format]]. For example:

{{{
(setq gnus-summary-line-format "%U%R%z %d  %-30n  %B%s\n")
}}}

Here are some common keybindings:

* `C-h m' -- View all keybindings
* `RET' -- View article under point
* `n' -- Next new article
* `p' -- Previous article
* `SPC' -- Scroll down / Next article
* `DEL' -- Scroll up
* `F' -- Reply to *news* thread and quote the article.
* `R' -- Reply to *mail* and quote the sender
* `m' -- New mail
* `a' -- New Post
* `c' -- Catchup (fetch new articles)
* `C-u / t' -- Show only new posts.
* `t' -- Toggle post headers.
* `W w' -- Word-wrap the current post.
* `L' -- Create a *score entry* (##?## for help)

=== Composing Mail ===

When you use a *Compose* key (say, ##m##), you'll enter a new buffer.
Fill out the ##Subject:## header and enter your post body below ##--text follows this line--##. You may add additional headers above this line (e.g. ##X-Drunk-as-a-lord: yes##).

You likely want automatic word-wrapping. Add the following
lines in ##~/.gnus##:

{{{
(defun my-message-mode-setup ()
  (setq fill-column 72)
  (turn-on-auto-fill))

(add-hook 'message-mode-hook 'my-message-mode-setup)
}}}

Commands for composing mail:

* ##C-c C-c## -- Send message
* ##C-c C-d## -- Save message as draft
* ##C-c C-k## -- Kill message
* ##C-c C-m f## -- Attach file
* ##M-q## -- Reformat paragraph
* ##M-x message-caesar-region## -- encode region using ROT13

=== Reading News ===

This stuff pertains to both news *and* mail reading, which is
one of the best things about Gnus: it provides you with a powerful and
*unified* set of commands.

(This section focuses only on the ##group## and ##summary## buffers)

See ##C-h m## for a list of commands. Here are the most common ones.

|| Key || Group Buffer                        || Summary Buffer          || 
|| n   || Next group with *unread* articles   || Next unread article     ||
|| p   || Previous group with unread articles || Previous unread article ||
|| N   || Next group                          || Next article            ||
|| P   || Previous group                      || Previous article        ||
|| C-n || Next line                           || Next line               ||
|| C-p || Previous line                       || Previous line           ||

Most of the time, you only want to select *new* articles that you haven't yet read, 
so *jumping to new articles* is prioritized, though accessing old / read articles is still easy.

If you reach the bottom of a summary buffer and press ##n##, Gnus will load the first unread article for the next group (So you can use one hand to press ##n##, and the other to hold a cup of tea).

##C-n## and ##C-p## are *never* rebound. They are the same in every Emacs mode.

You can scroll an individual article with ##SPC## and ##DEL##.

=== Help! ===

Soon enough (after about 17 seconds of
using Gnus), you'll find yourself in a situation where you have no idea
how to do something. Here are some ways to search for solutions:

* ##C-h i d m gnus## -- Read the Gnus Manual (Press ##s## to search).
* ##C-h ?## -- Displays the system help menu.
* ##C-h m## -- Displays the current mode's keybindings.
* ##C-h b## -- Displays all Emacs keybindings.
* The Menu Bar -- Common Gnus functions are sometimes kept here.

If you're really stuck, you can ask other Gnusers. Proper places for this are:

* gnu.emacs.gnus
* news.software.readers
* gnus.ding -- (If you're on an Alpha release)
* EmacsNewsgroups

Also remember:
* ##C-h b## lists all keybindings
* Gnus' prompts are usually *tab-completable*.
* You can use all Emacs functions from in Gnus.

== Mail ==

Gnus is primarily a news reader, but *this is a good thing*, as it turns
out "managing email in a very newsreaderly fashion" is very efficient.

It would be an uphill battle if you tried to make Gnus "behave like a /normal/
email client". Instead of telling Gnus to change, let Gnus change /you/.

You need to tell Gnus:

* How to *store* mail on the local disk.
* *Where* to get the mail messages.
* How to *send* new mail.

The difference between mail *backends* and mail *sources* is that a backend tells
Gnus how to store messages, whereas mail sources specify where to fetch them. Gnus fetches 
mail from the source, and stores it in the backend. Sources are stored in ##mail-sources##. Backends are
stored in ##gnus-secondary-select-methods##.

The ##nnimap## backend is an exception: the IMAP server itself
stores your mail; it doesn't need to be fetched.

=== Backends ===

The Gnus manual lists many backends. For news, theres:

* ##nntp## -- Access an NNTP Netnews server.
* ##nnspool## -- If you have a local news spool
** (Leafnode users should always use ##nntp##)

There are many mail backends. This list has more popular choices near the top:

* ##nnmaildir## -- Stores messages in files in a folder
* ##nnimap## -- Manages mail on server. Good if you use multiple devices.
* ##nnmbox## -- Stores messages all in one ##~/mbox## file.
* ##nnfolder## -- Uses the ##mbox## format, but uses separate files.
* ##nnml## -- Generates an "overview" file to make parsing fast.
* ##nnmh## -- The MH format where file names are numbered.
* ##nnbabyl## -- Like ##mbox## but with delimiters for message start/ends.

See MailFiles for a more complete analysis.

=== More Advice ===

You can choose a server name by adding text to the server string:

     (add-to-list 'gnus-secondary-select-methods '(nnml "x")) ; nnml+x:foo
     (add-to-list 'gnus-secondary-select-methods '(nnml ""))  ; nnml:foo

This is useful when you have multiple ##nnml## inboxes.

Each server has a set of optional *server parameters*. For example, if you use
the ##nnmbox## backend, then you can specify a different mbox file
to use (the default is ##~/mbox##):

     (add-to-list 'gnus-secondary-select-methods
                  '(nnmbox ""
                    (nnmbox-mbox-file "~/MAIL")
                    (nnmbox-active-file "~/Mail.active")))

See the [[https://gnus.org/manual/gnus_84.html#Unix-Mail-Box Gnus mbox page]] for more parameters.

Each server wants to *own* the
directories and files it writes to, and gets very angry if it finds that
they are already occupied. Therefore, the ##nnchoke-frumple-file## and the
##nnchoke-gargle-directory## parameters are pretty important. For example,
if you have used Pine before Gnus, then you are going to have a ##~/Mail/##
directory which is used by Pine. Therefore, you should add the right
parameters to tell Gnus to stay away from that directory. For example:

     (add-to-list 'gnus-secondary-select-methods
                  '(nnml ""
                    (nnml-directory "~/GnusMail/")
                    (nnml-active-file "~/GnusMail/active")))

The file-per-message and file-per-group types of backends each have a
parameter nnchoke-directory, the file-per-server type of backend has a
nnchoke-mbox-file parameter. All these backends have a
nnchoke-active-file parameter.

=== Fetching and Sending ===

The previous section has explained how Gnus fetches mail to read.
But the question is, how does the mail actually get to
your local disk in the first place? For many people, the answer is
*POP* ([b]P[/b]ost [b]O[/b]ffice [b]P[/b]rotocol). Gnus can connect
to a POP server, which is a remote location holding your mail.

##mail-sources## can store several places for getting new mail 
for getting new mail. See Mail Source Specifiers (Gnus), which contains
a great section about this variable. In this tutorial, suffice it to
provide a template for POP users, that will deal with the lion's share
of the cases.

     (setq mail-sources '((pop :server "mail.example.com"
                               :user   "jrl@example.com"
                               :password "passw0rd")))

Without ##:password##, Gnus will ask for your password every time.

You can also have several servers:

     (setq mail-sources '((pop :server "mail1.example.com" :user "jrl")
                          (pop :server "serv2.example.com" :user "joe")))

For *sending* mail, you'll likely use SMTP:

     (setq send-mail-function 'smtpmail-send-it)             ; Not for Gnus
     (setq message-send-mail-function 'smtpmail-send-it)     ; For Gnus
     (setq smtpmail-default-smtp-server "mail.example.com")  ; SMTP server that you'll send from.
     (setq smtpmail-debug-info t)                            ; only to debug problems

Say ##C-h v message-send-mail-function## for more details on sending mail.

=== Expiry ===

Gnus' way of "deleting" mail is called *Expiry*. Mark a message as expirable with ##E##. It will be deleted after [b]1 week[/b].

You may also tell Gnus to *automatically* expire mail after reading them:

* Total Expire -- Treat *all* mail marked "as read" as expirable.
* Auto Expire -- Mark mail as expirable on-read (can be unmarked manually)

{{{
;; These variables take a regexp input.
(setq gnus-auto-expirable-newsgroups  "nnmbox:mail.misc"
      gnus-total-expirable-newsgroups "nnml:mail.misc")
}}}

Auto-expire is usually *faster* than Total-expire.

Gnus keeps lists of:

* All *expirable* messages,
* All *dormant* messages,
* All *ticked* messages,
* All *read* messages.

When *total-expire* is on, Gnus needs to make sure every *read* message isn't
ticked or dormant first, before confirming it's expirable.

When *auto-expire* is on, Gnus only needs to check for messages marked as expirable.

You may opt to simply run expiry manual on your own when you feel like it. 
In that case, you can tell Gnus to no longer expire on quit:

{{{
(remove-hook 'gnus-summary-prepare-exit-hook
             'gnus-summary-expire-articles)
}}}

Then run ##gnus-groups-expire-all-groups## with ##C-c C-M-x##.

: *Adaptive scoring* only works with total-expire.

=== Marks ===

The following are the default article marks and behavior:

* _unmarked_ -- All new messages are unmarked.
* _read_ -- Not shown on disk by default, but kept unless expirable.
** ##C-u M-g## shows all read mail.
* _dormant_ -- Not shown by default. Shew them with ##/ D##
* _ticked_ -- Ticked messages are always shown and can't expire.
* _expirable_ -- Will be deleted automatically over time.

=== Migrating old mail ===

Probably, you've been reading mail in pre-Gnus times, right? And surely
you wish to carry this over to Gnus. Well, I haven't found a real good
way to do it, but I can offer a few suggestions for doing it at least
semi-automatically.

One way of getting at your old mail is to type G f, and to then enter
the name of your old mail file. This provides read-only access to your
mails. For some people, this might be sufficient. (With G f, you have
created an nndoc group.)

Some people might want to have their mails available in their normal
mail groups hierarchy. That's simple, just create an nndoc group for
your mail file, then mark all messages in it with M P a, then copy all
of them over to a normal mail group, with B c.

This is good for people who wish to keep their old arrangement of
folders, and who have a one-to-one correspondence between old mail files
and new Gnus groups. But some people might wish to split up their mails
differently. For them, it might be useful to set up nnmail-split-methods
correctly and to use B r instead of B c. This goes through all
process-marked messages and subjects them to the same splitting process
that newly arriving messages go through. (Whee! What a run-on sentence!)


=== Making Gnus behave like other mail readers ===

Gnus *hides* messages after they've been read. Enter a group with ##C-u RET## to view these messages.

: This may take a long time -- [[ColinBaxter]]

When a new post is added to a thread, you can make sure you also see the old read parent with:

     (setq gnus-fetch-old-headers t)

When reading mail from IMAP, it may be nice to mark messages as read on the server-side.(*todo*)

=== Archiving Mail ===

(TODO)

== Multiple Mailboxes ==

This example uses multiple mailboxes with multiple ##From:## headers.

{{{
(setq my-email-addresses '("user@gmail.com"
			   "user@domain.net"
                           "user@work.com"
                           "user@isp.com"
			   "user@communitygroup.org"))
(setq message-alternative-emails
      (regexp-opt my-email-addresses))

;; Gnus from manipulation
(setq gnus-from-selected-index 0)
(defun gnus-loop-from ()
  (interactive)
  (setq gnus-article-current-point (point))
  (goto-char (point-min))
  (if (eq gnus-from-selected-index (length my-email-addresses))
      (setq gnus-from-selected-index 0) nil)
  (while (re-search-forward "^From:.*$" nil t)
    (replace-match (concat "From: " user-full-name " <" (nth gnus-from-selected-index my-email-addresses) ">")))
  (goto-char gnus-article-current-point)
  (setq gnus-from-selected-index (+ gnus-from-selected-index 1)))

(global-set-key (kbd "C-c f") 'gnus-loop-from)
}}}

I've made what is for me a slightly more useful version of this:

{{{
(setq my-email-addresses '(...))

(defun bsb/loop-from ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward
           "^From: *\\([^<\n]*?\\) *\\(<\\([^>\n]*\\)>\\)?$" nil t)
      (let* ((no-name (null (match-string 2)))
             (name (if no-name user-full-name (match-string 1)))
             (address (match-string (if no-name 1 3))))
        (replace-match (concat "From: " name
                               " <" (bsb/next-address address) ">"))))))

(defun bsb/next-address (address)
  (let ((found (member address bsb/email-addresses)))
    (if found
        (if (cdr found)
            (cadr found)
          (car bsb/email-addresses))
      (if (eq last-command this-command)
          (setq bsb/from-selected-index
                (mod (+ bsb/from-selected-index 1) (length bsb/email-addresses)))
        (setq bsb/from-selected-index 0))
      (nth bsb/from-selected-index bsb/email-addresses))))
}}}

This replaces an address with the next one in the list rather than starting from the first.  Of course, if the ##From:## line does not have a recognised address it just behaves as before.  Also it preserves any friendly name that
might be on the line and the save-excursion prevents the point from jumping about as the address length changes.



== Glossary ==

* *Message* -- General term for either Mail or News
* *Mail* -- A message sent over email
* *Post* -- A message sent over NNTP / News
* *Backend* -- A Gnus facility for fetching messages over a protocol
* *Server* -- A single instance of a backend.
* *Select Method* -- Synonymous with Server
* *Secondary Method* -- An additional server
* *Group* -- A newsgroup (Gnus treats a mailbox as a group, too)
* *Expirable* -- A message marked for deletion
* *Marks* -- A status marker on a message (##R## means ##read##)
* [b]$[/b] -- Words beginning with a ##$## are environment variables
* *User* -- You!
* *You* -- A very pretty user 🩵

== External Links ==
* [[https://www.gnu.org/software/emacs/manual/html_mono/gnus.html Gnus Manual]] 
* [http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/gnus/gnus.el gnus.el] -- The latest upstream version of Gnus
** To find the latest version number, search for ##defconst gnus-version-number## (may be in Beta)

----

CategoryGnus
