Using pipe commands with Emacs can be a bit tricky. 

== Extensive script for piping things in & out of Emacs and more ==

https://github.com/agzam/mx-piper 


== Piping things into Emacs ==
This snippet will make pipes play nicely with EmacsClient.


[new]
I defined the following function within .bashrc and start emacs under cygwin with the command <tt>e</tt>.
<pre>
e() {
    local TMP;
    if [[ "$1" == "-" ]]; then
        TMP="$(mktemp /tmp/emacsstdinXXX)";
        cat >"$TMP";
        if ! emacsclient --alternate-editor /usr/bin/false --eval "(let ((b (create-file-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"${TMP}\") (delete-file \"${TMP}\"))"  > /dev/null 2>&1; then
            emacs --eval "(let ((b (create-file-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"${TMP}\") (delete-file \"${TMP}\"))" &
        fi;
    else
        emacsclient --alternate-editor "emacs" --no-wait "$@" > /dev/null 2>&1 &
    fi;
}
</pre>
Editing a file <tt>text.txt</tt>:
<pre>
e text.txt
</pre>
Piping something:
<pre>
echo "something" | e -
</pre>
Using <tt>--alternate-editor</tt> and <tt>--eval</tt> together did not work for me. I don't know why.
The bad thing about <tt>e</tt> is that it relies on an undocumented feature of emacsclient.
It is assumed that <tt>emacsclient --alternate-editor /usr/bin/false ...</tt> returns the exit code of <tt>false</tt> if the alternate editor is used and that it returns SUCCESS if the server can successfully be contacted.

-- TN

I've simplified this down to the following shell script, which I keep in ~/bin/e:

<pre>
if [ -z "$1" ]
then
    TMP="$(mktemp /tmp/stdin-XXX)"
    cat >$TMP
    emacsclient -a emacs $TMP
    rm $TMP
else
    emacsclient -a emacs "$@"
fi
</pre>

It's not *quite* the same but I value the simplicity of it. With this you no longer need 'e -' to indicate STDIN, e will just look for STDIN whenever no files are specified.

== Piping things through Emacs ==

I've adapted the above to do something a bit more substantial. This variant allows you to run Emacs Lisp functions in your standard process pipelines. **tl;dr** Put that in your pipe and smoke it!

<pre>
#!/bin/bash

# f --- Use emacsclient and stand-alone elisp functions in a pipe

# Usage example:

# echo "you are not kidding" | f -e ~/bin/replace-my-regexp.el "replace-my-regexp" "are not" "ainâ€™t"

# Output: you ainâ€™t kidding

# Reminder: use single quotes instead of double quotes for regexps
# with backslashes in them to make formatting convenient!

# Notes:

# â€¢ we just throw away -e and always:
#  â€¢ load the code in the path specified by fâ€™s second argument
#  â€¢ run the function named by fâ€™s third argument,
#    â€¢ passing it the remaining arguments as data

# For reasons of encapsulation we assume that the function actually
# resides in the "f/" namespace.  For example,
# ~/bin/replace-my-regexp.el has contents:

# (defun f/replace-my-regexp (a b)
#   (goto-char (point-min))
#   (while (re-search-forward a nil t)
#     (replace-match b))
#   (buffer-substring-no-properties (point-min) (point-max)))

# In addition, we unbind f/-functions after we use them with
# `fmakunbound', so that your Emacs server isnâ€™t cluttered.

# Context:

# The functionality provided should be seen as conceptually similar to
# Babashka (https://github.com/babashka/babashka), however, f requires
# a full Emacs server rather than a simplified interpreter like sci
# (https://github.com/borkdude/sci).

# Happy scripting!

# Code:

oldIFS="$IFS"
IFS=$'ðŸ˜ƒ'

# designate a temporary file
TMP="$(mktemp /tmp/stdin-XXX)"
# write input to temporary file
cat >$TMP
# open the temporary file in emacs
emacsclient -a emacs -n $TMP
# load and run commands, as specified, on the contents of the temporary file
# (suppressing messages, as well as capturing and suppressing the final output)

OUT=`emacsclient -a emacs -e "(progn (set-buffer (get-buffer (substring \"$TMP\" 5)))"\
"(let* ((inhibit-message t) (message-log-max nil)"\
"(args (split-string \"$*\" \"ðŸ˜ƒ\"))"\
"(f (intern (concat \"f/\" (third args))))"\
"(ret (progn (load (second args)) (apply f (nthcdr 3 args)))))"\
"(save-buffer)"\
"(kill-buffer (current-buffer))"\
"(fmakunbound f)"\
")))"`

# cat the contents of the temporary file to standard out
cat $TMP
rm $TMP
IFS="$oldIFS"
</pre>

== 'Pipes' inside Emacs with Eshell =

If you happen to be using Eshell, you can push data around with commands like this:

<pre>
cat myfile > (switch-to-buffer "*my-buf*")
</pre>
