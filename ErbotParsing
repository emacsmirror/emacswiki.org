(This section is current as of 2023 -deego)


== Parsing/Lispification and Lisp interpreter ==


To set the **notes** for new **term** "myterm" to "my notes", you can type one of three things: (1) ##,myterm is my notes## (2) ##,(fs-set-term "myterm" "my notes")##, or finally, (3) ##,(set-term "myterm" "my notes")##. (1) is referrred to as a natural-language- or English- syntax. (2) is the lisp form, and finally, (3) shows that if the `fs-' prefixes are omitted, a codewalker adds them right back. Internally, all three expressions eventually convert to form (2) which then converts to ##(fsi-set-term "myterm" "my notes")## before actually getting executed. 

You often use the easiest paren-free English syntax to command the bot, but as is inevitable with any NL-parsing, you will eventually run into ambiguities, edge-cases and conflicts. Your best option in such cases is to use the precise lisp syntax for more fine-tuned control. But, you shouldn't have to remember the equivalent lisp-form. You should simply be able to look it up! You simply ask the bot itself via ##(fs-parse)## which is also aliased to ##(fs-lispify)##: 

    <deego> ,(parse "Emacs is a good editor")                                                                                                                                                  
    <fsbot> (fs-set-term "Emacs" "a good editor")


This tells you that a sentence of the form "foo is bar" gets parsed into an `fs-set-term' form. So far, the bot has merely parsed the command, not actually executed it. 
Next, you actually execute the command and tell the bot that Emacs is a good editor:

   <deego> ,Emacs is a good editor                                                                                                                                                          
   <fsbot> Created new note for "Emacs"

As should be clear by now, you could have also used the lisp-form to effect the above:

    <deego>  ,(set-term "Emacs" "a good editor")
    <fsbot> Created new note for "Emacs"                     


This sets the term, persistent across sessions, in the publicly available file **botbbdb**.

An additional note for an existing term is entered via "is also" whose parse is:
 
  <deego> ,(parse "Emacs is also a great OS")                                                                                                                                          
  <fsbot> (fs-set-also "Emacs" "a great OS")


As we mentioned, for convenience, you can skip the `fs-' prefix when commanding fsbot, and it is always automatically added for you. Thus, instead of having to type ##(fs-parse ..)##, you were able to simply type ##(parse...)##.


As we saw above, the bot understands and executes a restricted and modified subset of lisp we refer to as **fslisp**. Furthermore, it sandboxes everything to ensure we internally always stay in the `fs-' namespace. These `fs-' functions and macros use various codewalkers, are carefully designed to avoid the irc user being able to do things like ##(shell-command "rm -rf /")##, ##(eval '(kill-system))##, etc, and are therefore sometimes very different from their usual emacs counterparts. Another source of difference arises because they were written with bot-related functionality in mind. For example, `fs-replace-string' is used to replace strings within the notes of terms, and is thus very  different from the usual `replace-string' found in emacs.

You have about 1000 such `fs-' commands available, referred to as **botcommands**. Internally, some botcommands are macros and some are functions. These include some powerful building blocks like `fs-while', `fs-mapcar' and cousins, `fs-eval', `fs-read', `fs-error', `fs-setq' and `fs-makunbound', `fs-apply', `fs-funcall', `fs-quote', `fs-lambda', etc.  


Among those included are `fs-defun', `fs-fmakunbound', and `fs-defalias'. In other words, you can build upon the initial botcommands and create - or remove - as many more as you like.

Thus, you have read/write access to the `fs-' space. This rw access applies to all new functions you create, but not to the initial core `fs-' functionality, which has read-only access. Thus, trying ##(fmakunbound 'fmakunbound)## - equivalently  ##(fs-fmakunbound 'fs-fmakunbound)## - will lead to an error because `fs-fmakunbound' is part of the core functionality. Such core functions should behave in a consistent fashion, for everyone to use, and should not change just because some irc user changed them via a PM. Another example of a **core botcommand** is `fs-set-term'.


You can query and search among the ~ 1000 bot-commands available to you using `fs-commands':


    <deego> , (commands "^a")
    <fsbot> 7 matches.  (a ac and append apply apropos av)

This means that you have access to the following bot commands that start with the letter a: `fs-a', `fs-ac', `fs-and', `fs-append', etc.

This was, in essence, an apropos-search, but restricted to items with the prefix `fs-'. A related command is fs-apropos. It searches over all emacs functions/variables, no longer restricting to the `fs-' prefix:

    <deego> , (apropos "^ac")
    <fsbot> 11 matches.  (acapulco accept-process-output access-file
        accessible-keymaps ache aching acid acons acos
        activate-input-method active-minibuffer-window)


Since you have access to `fs-defun' and `fs-setq', you can define your own `fs-' functions and set your own `fs-' variables. Once defined, these remain persistent across sessions. These are referred to as **userfunctions** and **uservariables**, respectively, and get stored in the publicly available files **userfunctions.el** and **uservariables.el**. /Uservariables should not be confused with terms/, which are set via `fs-set-term', as illustrated earlier. 


=== Interaction History, logging and trash: ===

*Summary*: Use ##,history## for your private session-history. ##,dump## to dump previous interactions, ##,trash*## to see undo-information, and ##,botlog## to see everyone's rw changes. 


*Interaction:* Every interaction with the bot is logged via multiple logging mechanisms, detailed below. (The full record of) an *interaction* refers to the set {your command, its parse, the bot's response, and finally, any *undo-information* it generated}. Each interaction is assigned a random, unique name.

*Privacy:* Every interaction, especially when *rw*, enters a permanent, public record on the web. Please plan accordingly! Though *ro* interactions are somewhat semi-private to you, as explained below, I can make no guarantee of privacy even for this case. 

*ro* and *rw*: *rw* refers to an interaction that attempts to make any changes to the bot database, set any term or alter any functions or variables  (even temporarily.).  *ro* refers to other interactions that merely query a bot for information.

*Logtmp:* Every interaction generates a temporary log, available in an unlisted url under the logtmp/ folder.  These logs are subject to periodic deletion. 

*History:* When /query-ing the bot, ##,history## will list all your previous commands along with the name assigned to the corresponding interaction-record. In a channel, it lists a history of the entire channel's interactions, irrespective of the author. To dump the full record, use ##,dump##.

*Dump:* ##,dump N## will dump the n'th-oldest interaction. ##,dump <partial-name>## is another way to dump the interaction, where the name was looked up via typing ##,history##.

*Logfull:* rw interactions also get listed under the logfull/ folder. Unlike logtmp, these logs are permanent. As mentioned above, the record includes all undo-information.

*Botlog:* Also available in the botlog/ folder on the web. ##,botlog N## will dump a list of all rw interactions on day #(today - N). This includes every single rw change, made by any user, on any channel. Every interaction will also include a pointer to its logfull-record.

*Undo:* Every rw interaction's record also includes an *undo* entry: enough information to reconstruct the original database. This information becomes part of a permanent public record on the web. It also gets stored in the *trashcan*.


*Trashcan:* While all undo-information is part of a permanent public web record, it is also stored in the bot's db temporarily via a trash-mechanism. A *trash-term* is simply a term that starts with "FsTrash". Whenever any undo-information is created, new trash-term(s) are created. ##,trashlist## returns a list of trash-terms, which can then be queried like any other term. You can then use this information to undo any accidental damage. ##,trashtrash## empties the trashcan; that is, it deletes all terms starting with FsTrash.






=== Some notes on the parser === 

Internally, things get pretty complex. For example, ##(fs-apply SUBJECT OBJECT)## is fairly complex because it has to handle all kinds of cases in the secure `fs-' model: the subject could be a variable, a lambda, a quoted lambda, a quoted symbol, etc. The object could be a variable or a list. Additionally, of course, the subject/object can be other fslisp-expressions that result in any of the aforementioned possibilities. Among other things, in each case, the codewalkers need to ensure that we don't allow jailbreaking out of the `fs-' namespace.  


Here's another reminder that everything you do is actually happening in the `fs-' space. When you  ##,(defun increment (myvar) (+ 1 (apply 'myfun myvar)))##, it first internally gets parsed as ##,(fs-defun fs-increment (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. That works because `fs-defun', `fs-apply', and ##`fs-+'## are functions/macros that are provided to you in the core functionality, and because you hopefully already `defun'd a `fs-myfun' prior to this. Notice how the parser figures out that it needs to prefix the quoted expression as well. It converts `myfun' to `fs-myfun'. (If it didn't, you would be able to jailbreak to access things like ##'shell-command##). 

In some contexts, however, quoted expressions should *NOT* be prefixed with `fs-'. When you type ##,(format "%s" 'a)##, you expect the answer to be "a", and indeed, the parser correctly figures out that it should NOT, in this case, convert ##'a## to ##'fs-a##.

`fs-parse' is idempotent; this equality holds: (equal (parse foo) (parse (parse foo)). Thus, other than the fs-prefix codewalker, lisp-expressions stay unaltered after parsing.

While the lisp parser is pretty stable and reliable, the english parser is anything but. The latter is heavily context-dependent. For example, 
##,describe foo## gets parsed as ##,([fs-]describe "foo")##  but ##,foo is bar## gets parsed as ##,(set-term 'foo 'bar)##. Furthermore, the latter would get parsed as ##(foo 'is 'bar)## if a user-function foo existed. The English parser also evolves with time, at the whim of the author, to try to make fsbot more DWIM-my. This context-dependence is regarded by the author as a feature, not a bug. If that is a problem, please try using the lisp syntax instead. English sucks as a programming language. That's why you also have lisp at your disposal.



=== `fs-' stripping ===
The definition of `fs-increment' that you just created is built upon several other `fs-' functions. As we alluded to above, you can immediately see your new function in the publicly available file userfunctions.el. Or you can ask fsbot to `find-function' the function for you and return a pretty-printed output. When you type ##,(find-function 'fs-increment)##, fsbot will return a readable version of the definition, by stripping all the `fs-' prefixes. Thus, when you see the bot returning this definition: ##(lambda (myvar) (+ 1 (apply 'myfun myvar)))##, keep in mind that's just a readable shorthand for ##(lambda (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. The former does not always equal the latter. Fsbot's output is readable but inaccurate if taken literally. If you want the bot to retain the `fs-' prefixes when printing the definition, you can use other botcommands such as `find-function-literally' or `ffl'.


=== More on fs-find-function ===
##(fs-find-function 'foo)## first looks for an emacs function `foo', and when that doesn't work, it looks for a userfunction `fs-foo'. Thus, provided a built-in `foo' does not exist, you can use `foo' to refer to `fs-foo' when using fs-find-function. `fs-ff' is an alias for `fs-find-function'. Putting all these shortcuts together: You will often see #emacsers typing the English-form ##,ff myfun## instead of the more verbose form ##,(fs-find-function 'fs-myfun)##. The English form gets parsed as ##(fs-find-function 'myfun)##, which initially looks for `myfun', falls back upon `fs-myfun', and eventually returns the `fs-' stripped definition of `fs-myfun'. You will find similar shortcuts and fallbacks in many other botcommands, meant to promote convenience and brevity. Here's another example: `ff' actually has yet another fallback: it punts to `fs-find-variable' when the latter is expected to work. That arose because far too often, I noticed people trying `ff' when they actually meant `fv', which is a shortcut for `fs-find-variable'.


=== An early first stab at a GPT interface ===

This is ***expensive***. If there's too much abuse, I will disable private queries for this functionality.

    <deego> , gpt which is the world's tiniest editor? 
    <fsbot> The world's tiniest editor is probably "Micro Emacs" or "µemacs", which is a compact text editor designed for Unix-like operating systems


If you want your parens, quotes, etc, passed along to GPT, please use elisp when talking to fsbot:

    <deego> , (gpt "complete: (loop for i from 1 to 10 " )
    <fsbot> do (print i))

rather than this:

    <deego> , gpt complete: (loop for i from 1 to 10)
    <fsbot> Life is selling REVOLUTIONARY HAIR PRODUCTS!





 

----

ErBot

