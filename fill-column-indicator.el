;;; fill-column-indicator.el --- graphically indicate the fill column

;; Copyright (c) 2011 Alp Aker 

;; Author: Alp Aker <aker@pitt.edu>
;; Version: 0.31
;; Keywords: convenience

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2 of the
;; License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; A copy of the GNU General Public License can be obtained from the
;; Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
;; MA 02111-1307 USA

;;; Commentary:

;; Many modern editors and IDEs can graphically indicate the location of the
;; fill column, either by shading the area to the right of the fill column or
;; by drawing a thin line (in design parlance, a `rule') down the length of
;; the editing window.  Fill-column-indicator implements both of these
;; facilities in Emacs. 

;; Installation
;; ============

;; Put this file in your load path and put 
;; 
;;   (require 'fill-column-indicator)
;;
;; in your .emacs.  

;; Usage
;; =====

;; To toggle graphical indication of the fill column in a buffer, use the
;; command `fci-mode'.

;; Fill-column-indicator has two modes of operation:

;; o In shading mode, it shades the portion of the window to the right of the
;;   fill column.  This is the default.

;; o In rule mode, it draws a thin line at the fill column.

;; The mode of operation is controlled by the variable `fci-style'; the
;; recognized values are 'shading and 'rule.  If you'd like fci-mode to use a
;; rule by default, put
;;
;;   (setq fci-style 'rule) 
;;
;; in your .emacs.  (Buffer-local values of fci-style are supported.)

;; Configuration:  Shading Style
;; =============================

;; The appearance of the shading is controlled by the face `fci-shading'; its
;; attributes can be set like those of any face.

;; Configuration:  Rule Style
;; ==========================

;; On window systems the rule is drawn using an image generated by fci-mode;
;; the rule's width (in pixels) is determined by the variable
;; `fci-rule-width'.  On character terminals the rule is drawn using the
;; character specified by `fci-rule-character'.  In both cases the color is
;; controlled by `fci-rule-color'.  If you'd like the rule to be drawn using
;; fci-rule-character even on graphical displays, set
;; `fci-always-use-textual-rule' to a non-nil value.

;; The image formats used by fci-mode are XPM, PBM, and XBM.  By default, it
;; tries to use use them in that order.  You can specify a particular format
;; by setting `fci-rule-image-format' to either 'xpm, 'xpm, or 'xbm.

;; Other Options
;; =============

;; When `truncate-lines' is nil, the effect of drawing a fill-column
;; indicator is very odd looking (think about what it means to talk about
;; "the" location of the fill column in a window with continuation
;; lines).  For this reason, fci-mode sets truncate-lines to t in buffers in
;; which it is enabled and restores it to its previous value when
;; disabled.  You can turn off this feature by setting
;; `fci-handle-truncate-lines' to nil.

;; If `line-move-visual' is t, then vertical navigation can behave oddly in
;; one or two edge cases while fci-mode is enabled (this is due to a bug in C
;; code).  By default fci-mode locally sets line-move-visual to nil when
;; enabled and restores it when disabled.  This can be suppressed by setting
;; `fci-handle-line-move-visual' to nil.  (But you shouldn't want to do this.
;; There's no reason to use line-move-visual if truncate-lines is t, and it
;; doesn't make sense to use something like fci-mode when truncate-lines is
;; nil.)

;; Troubleshooting
;; ===============

;; o If the fill-column indication is misaligned on some lines but otherwise
;;   looks normal, then you're most likely not displaying the buffer contents
;;   with a monospaced font.  Check whether one of the lines in question has
;;   a non-ascii character that's wider or shorter than the normal character
;;   width.  Also, be aware that certain font-lock themes set some faces so
;;   that they look monospaced but aren't quite so.

;; o If the rule appears as a dashed (rather than uninterrupted) line on
;;   window systems, try changing the image format. (See the above section on
;;   configuring the rule style indicator.)

;; o If the terminal type does not support at least inverse video, then
;;   shading is impossible, and you should set fci-style to 'rule.

;; o Although the XBM format is natively supported by Emacs, the
;;   implementation on some ports is incomplete; the v23 and v24 Mac OS X
;;   ports are examples.  On these systems XBM images are always drawn in the
;;   foreground color of the frame's default face, in which case one cannot
;;   control the color of the rule.  Use XPM or PBM images instead.

;; Known Issues
;; ============

;; o The indicator extends only to end of the buffer contents (as opposed to
;;   running the full length of the editing window).

;; o If the buffer contents do not end in a newline, then the indicator
;;   extends only to the penultimate line.

;; o When using shading style on a character terminal, lines that fall one
;;   character short of the window border show the frame background color in
;;   the last column instead of shading.  This appears to be an artifact of
;;   the mechanism that displays truncation and line continuation glyphs; a
;;   fix will probably require patching the C code.

;; Todo
;; ====

;; o Play well with outline minor mode and other forms of folding
;;   (nxml-outln, etc.).

;;; Code:

;;; Version 

(unless (< 21 emacs-major-version)
  (error "Fill-column-indicator requires version 22 or later"))

;;; Customization Menu Options

(defgroup fill-column-indicator nil
 "Graphically indicate the fill-column."
 :tag "Fill-Column Indicator"
 :group 'convenience)

(defcustom fci-style 'shading
  "How fci-mode should indicate the fill-column.
If `shading', each line will be shaded past the fill column.  If
`rule', a thin rule (line) will be drawn at the fill column.

Changes to this variable do not take effect until the mode
function `fci-mode' is run."
  :tag "Fill-Column Style"
  :group 'fill-column-indicator
  :type '(choice (symbol :tag "Shading" 'shading)
                 (symbol :tag "Rule (a line)" 'rule)))

(defface fci-shading
  '((((class grayscale) (background light)) (:background "gray80"))
    (((class grayscale) (background dark)) (:background "gray50"))
    (((class color) (min-colors 88) (background light)) (:background "gray80"))
    (((class color) (min-colors 88) (background dark)) (:background "gray50"))
    (((class color) (min-colors 16)) (:background "lightgray"))
    (((class color) (min-colors 8)) (:background "yellow"))
    (t (:inverse-video t)))
 "Face used by fci-mode to color the area past the fill column."
 :group 'fill-column-indicator
 :tag "Fill-column shading color")

;; Sharp quoting the anonymous function here causes an error; that should be
;; considered a bug in the widget library.  Also, we should really be using
;; :validate instead of :match, but that seems not to work with defcustom
;; widgets.
(defcustom fci-rule-width 2
  "Width, in pixels, of the fill-column rule on graphical displays.
The value must be less than the default character width of the selected frame.

Changes to this variable do not take effect until the mode
function `fci-mode' is run."
  :tag "Fill-Column Rule Width"
  :group 'fill-column-indicator
  :type  '(integer :match (lambda (w val) (<= val (frame-char-width)))))

(defcustom fci-rule-color nil
 "Color used to indicate the fill-column with a rule.
If nil, fill-column-indicator tries to make a sensible choice.

Changes to this variable do not take effect until the mode
function `fci-mode' is run."
 :group 'fill-column-indicator
 :tag "Fill-column rule color"
 :type '(choice (const :tag "Let fci-mode choose" nil)
                (color :tag "Specify a color")))

(defcustom fci-rule-image-format 
  (let ((formats (delq nil 
                       (mapcar #'(lambda (x) (if (image-type-available-p x) x))
                               image-types))))
    (cond
     ((memq 'xpm formats) 'xpm)
     ((memq 'pbm formats) 'pbm)
     (t 'xbm)))
  "Image format fci-mode uses for the fill-column rule on graphical displays.
See the comments in the package file for more information on the
choice of format."
  :tag "Fill-Column Rule Image Format"
  :group 'fill-column-indicator
  :type '(choice (symbol :tag "XPM" 'xpm)
                 (symbol :tag "PBM" 'pbm)
                 (symbol :tag "XBM" 'xbm)))

(defcustom fci-rule-character ?|
  "Character fci-mode uses on non-graphical displays.
This is also used when the chosen image format isn't supported."
  :tag "Fill-Column Rule Character"
  :group 'fill-column-indicator
  :type 'character)

(defcustom fci-always-use-textual-rule nil
  "If non-nil, fci-mode will draw the rule using characters instead of images.
Specifically, it will use `fci-rule-character' to draw the rule,
even on graphical displays."
  :tag "Don't Use Image for Fill-Column Rule"
  :group 'fill-column-indicator
  :type 'boolean)

(defcustom fci-handle-line-move-visual (< 22 emacs-major-version)
 "Whether fci-mode should set line-move-visual to nil while enabled.
If non-nil, fci-mode will set line-move-visual to nil in buffers in which it 
is enabled, and restore t to its previous value when disabled. 

Leaving this option set to the default value is recommended."
 :group 'fill-column-indicator
 :tag "Locally set line-move-visual to nil during fci-mode"
 :type 'boolean)

(defcustom fci-handle-truncate-lines t
 "Whether fci-mode should set truncate-lines to t while enabled.
If non-nil, fci-mode will set truncate-lines to t in buffers in which it  
is enabled, and restore it to its previous value when disabled. 

Leaving this option set to the default value is recommended."
 :group 'fill-column-indicator
 :tag "Locally set truncate-lines to t during fci-mode"
 :type 'boolean)

;;; Internal Variables

;; Stores the value of fill-column for our use.  
(defvar fci-column nil)
(make-variable-buffer-local 'fci-column)

;; Used by fci-after-change-function to call the right redrawing function
;; (shading or rule).  Set when fci-mode is called.
(defvar fci-put-overlays-function nil)
(make-variable-buffer-local 'fci-put-overlays-function)

;; Stores the rule image/propertized rule character for use by the drawing
;; function. Set when fci-mode is called.
(defvar fci-rule nil)
(make-variable-buffer-local 'fci-rule)

;; When we add padding to a line to make the fill-column indicator appear at
;; the right place, this is the start of the padding. 
(defconst fci-cursor-space (propertize " " 'cursor t))

;; Combined padding and rule for lines that end right at the fill column.
(defconst fci-cursor-rule nil)

;; Records whether fci-mode created a new buffer-display-table.
(defvar fci-made-display-table nil)
(make-variable-buffer-local 'fci-made-display-table)

;; Records whether fci-mode created a new buffer-display-table.
(defvar fci-prior-truncation-glyph nil)
(make-variable-buffer-local 'fci-prior-truncation-glyph)

;; If we nix line-move-visual in a buffer, we save its prior state here.
(defvar fci-saved-line-move-visual nil)
(make-variable-buffer-local 'fci-saved-line-move-visual)

;; If we turn on truncate-lines in a buffer, we save its prior state here.
(defvar fci-saved-truncate-lines nil)
(make-variable-buffer-local 'fci-saved-truncate-lines)

;;; Mode Definition

(define-minor-mode fci-mode
  "Toggle fci mode on and off.
Fci-mode indicates the location of the fill column, either by
shading the area of the window past the fill column or by
drawing a thin line (a `rule') at the fill column.

With prefix ARG, turn fci-mode on if and only if ARG is positive.

The following options control the appearance of the fill-column
indicator: `fci-style', `fci-shading', `fci-rule-width',
`fci-rule-color', and `fci-rule-character'.  For further options,
see the Customization menu or the package file.  (See the latter
for tips on troubleshooting.)"

  nil nil nil

      (if fci-mode
          ;; Enabling
          (progn
            (when (and fci-handle-line-move-visual
                       (boundp 'line-move-visual))
              (setq fci-saved-line-move-visual line-move-visual)
              (set (make-local-variable 'line-move-visual) nil))
            (when fci-handle-truncate-lines
              (setq fci-saved-truncate-lines truncate-lines)
              (set (make-local-variable 'truncate-lines) t))
            (setq fci-column fill-column)
            (cond 
             ((eq fci-style 'rule)
              (setq fci-put-overlays-function #'fci-put-overlays-rule
                    fci-rule (fci-make-rule)
                    fci-cursor-rule (propertize fci-rule 'cursor t)))
             ((eq fci-style 'shading)
              (setq fci-put-overlays-function #'fci-put-overlays-shading)
              ;; To handle char terminals.  We make this adjustment without
              ;; checking the terminal type, as it's innocuous on graphical
              ;; terminals and there's a remote chance someone using a daemon
              ;; might invoke the mode on a graphical terminal then display
              ;; the buffer on a character terminal.
              (let (gc)
                (if (not buffer-display-table)
                    (setq buffer-display-table (make-display-table)
                          fci-made-display-table t)
                  (setq fci-prior-truncation-glyph (aref buffer-display-table 0)))
                ;; If the user had the truncation glyph propertized, we're
                ;; going to overwrite that. The glyph-code mechanism won't
                ;; combine faces, and it doesn't seem worth it to go through
                ;; the hassle of manually merging the faces attributes.
                (setq gc (make-glyph-code (glyph-char (or fci-prior-truncation-glyph ?$))
                                          'fci-shading))
                (set-char-table-extra-slot buffer-display-table 0 gc)))
             (t
              (fci-mode -1)
              (error "Unrecognized value of `fci-style'")))
            (add-hook 'after-change-functions 'fci-after-change-function nil t)
            (ad-enable-advice 'set-fill-column 'after 'fill-column-indicator)
            (ad-activate 'set-fill-column)
            ;; In case we were already in fci-mode and are resetting the
            ;; indicator, clear out any existing overlays.
            (fci-delete-overlays-buffer)
            (fci-put-overlays-buffer))

        ;; Disabling
        (when (eq fci-style 'shading)
          (cond 
           (fci-made-display-table
            (setq buffer-display-table nil
                  fci-made-display-table nil))
           (fci-prior-truncation-glyph
            (set-char-table-extra-slot 0 fci-prior-truncation-glyph)
            (setq fci-prior-truncation-glyph nil))
           (t
            (set-char-table-extra-slot 0 nil))))
        (when (and fci-handle-line-move-visual
                   (boundp 'line-move-visual))
          (setq line-move-visual fci-saved-line-move-visual
                fci-saved-line-move-visual nil))
        (when fci-handle-truncate-lines
          (setq truncate-lines fci-saved-truncate-lines
                fci-saved-truncate-lines nil))
        (setq fci-column nil)
        (ad-disable-advice 'set-fill-column 'after 'fill-column-indicator)
        (ad-activate 'set-fill-column)
        (remove-hook 'after-change-functions 'fci-after-change-function t)
        (fci-delete-overlays-buffer)))

;;; Initialization for Rule Style

(defun fci-make-rule ()
  (let* ((color (if fci-rule-color
                    ;; User specified a color.  Check that it's valid.
                    (if (color-defined-p fci-rule-color)
                        fci-rule-color
                      (fci-mode -1)
                      (error 
                       "Value of `fci-rule-color' is not a recognized color"))
                  ;; Otherwise, choose an appropriate color.  
                  (fci-get-rule-color)))
         (rule (if (characterp fci-rule-character)
                   (propertize (char-to-string fci-rule-character)
                               'face
                               `(:foreground ,color :weight normal :slant normal))
                 (fci-mode -1)
                 (error "Value of `fci-rule-character' must be a character"))))
    (cond
     ((or (not (display-images-p))
          fci-always-use-textual-rule)
      rule)
     ((eq fci-rule-image-format 'xbm)
      (fci-make-xbm-rule fci-rule-width color rule))
     ((eq fci-rule-image-format 'pbm)
      (fci-make-pbm-rule fci-rule-width color rule))
     ((eq fci-rule-image-format 'xpm)
      (fci-make-xpm-rule fci-rule-width color rule))
     (t
      (fci-mode -1)
      (error "Unrecognized value of `fci-rule-image-format'")))))

(defun fci-get-rule-color ()
  (let ((light-bg (equal (frame-parameter (selected-frame) 
                                          'background-mode)
                         'light))
        (grays (display-grayscale-p))
        (planes (display-planes))
        (color (display-color-p)))
    (cond 
     ((and light-bg grays)
      "#cccccc")
     ((and (not light-bg) grays)
      "#7f7f7f")
     ((and color (> 3 planes))
      "lightgray")
     ((and color (> 2 planes))
      "yellow")
     (light-bg
      "black")
     (t
      "white"))))

;; The following three functions each crate a one-character string with the
;; rule image as its display property.  We use the textual rule character for
;; the underlying string (instead of a space) so that our failure mode is
;; more graceful in case the image display fails.  In addition, this handles
;; the case in which someone running a daemon invokes the mode on a graphical
;; display then subsequently displays the buffer on a terminal.

(defun fci-make-xpm-rule (width color rule)
  (let* ((ident (concat "/* XPM */\n"
                        "static char *rule[] = {\n"))
         (fcw (frame-char-width))
         (delta (- fcw width))
         (left (floor (/ delta 2.0)))
         (right (ceiling (/ delta 2.0)))
         (height  (frame-char-height))
         (swidth (number-to-string fcw))
         (sleft (number-to-string left))
         (sright (number-to-string right))
         (sheight (number-to-string height))
         (img-spec (concat "\"" swidth " " sheight " 2 1\",\n"))
         (color-spec (concat "\"1 c " color "\",\n"
                             "\"0 c None\",\n"))
         (row-pixels (concat "\"" 
                             (make-string left ?0)
                             (make-string width ?1)
                             (make-string right ?0)
                             "\",\n"))
         (raster (mapconcat #'identity (make-vector height row-pixels) ""))
         (end "};")
         (data (concat ident img-spec color-spec raster end)))
    (propertize rule
                'display
                (list 'image :type 'xpm :data data :ascent 'center))))

(defun fci-make-pbm-rule (width color rule)
  (let* ((height (frame-char-height))
         (sheight (number-to-string height))
         (fcw (frame-char-width))
         (delta (- fcw width))
         (left (floor (/ delta 2.0)))
         (right (ceiling (/ delta 2.0)))
         (swidth (number-to-string fcw))
         (ident "P1\n")
         (dims (concat swidth " " sheight "\n"))
         (left-pixels (mapconcat #'identity (make-vector left "0") " "))
         (right-pixels (mapconcat #'identity (make-vector right "0") " "))
         (rule-pixels (mapconcat #'identity (make-vector width "1") " "))
         (row-pixels (concat left-pixels " " rule-pixels " " right-pixels))
         (raster (mapconcat #'identity (make-vector height row-pixels) "\n"))
         (data (concat ident dims raster)))
    (propertize rule 
                'display
                (list 'image 
                      :type 'pbm :data data :mask 'heuristic
                      :foreground color :ascent 'center))))

(defun fci-make-xbm-rule (width color rule)
  (let* ((fcw (frame-char-width))
         (img-width (+ fcw (- 8 (% fcw 8))))
         (height (frame-char-height))
         (row-pixels (make-bool-vector img-width nil))
         (raster (make-vector height row-pixels))
         (offset (ceiling (/ (- img-width width) 2.0)))
         (i 0))
    (while (< i width)
      (aset row-pixels (+ i offset) t)
      (setq i (1+ i)))
    (propertize rule
                'display
                (list 'image 
                      :type 'xbm :data raster :foreground color 
                      :mask 'heuristic :ascent 'center 
                      :height height :width img-width))))

;;; Functions That Call Setting and Unsetting

(defmacro fci-sanitize-actions (&rest body)
  `(save-match-data
     (save-excursion
       (save-restriction
         (widen)
         ,@body))))

;; The main entry-point.  This is put in after-change-functions and locally
;; redraws the indicator after each buffer change.  Note that we redraw an
;; extra preceding line.  Motivation: at the beginning of a line,
;; insert-before-markers will grab the end marker of the overlay on the
;; previous line, in which case we need to reset the previous line's overlay
;; as well.  Unconditionally redoing the previous line is the fastest way to
;; handle that case.  (Using a hook on the overlay is conceptually tidier
;; but incurs the overhead of multiple extra lisp function calls.)
(defun fci-after-change-function (start end unused)
  (fci-sanitize-actions
      ;; Make sure our bounds span at least whole lines.
      (goto-char start)
      (setq start (line-beginning-position 0))
      (goto-char end)
      (setq end (line-beginning-position 2))
      ;; Clear any existing overlays.
      (fci-delete-overlays-region start end)
      ;; Then set the fill-column indicator in that region.
      (funcall fci-put-overlays-function start end)))

(defun fci-put-overlays-buffer ()
  (overlay-recenter (point-max))
  (fci-sanitize-actions
   (funcall fci-put-overlays-function (point-min) (point-max))))

(defun fci-delete-overlays-buffer ()
   (save-restriction
     (widen)
     (fci-delete-overlays-region (point-min) (point-max))))

;; Automatically reset the rule after changes to fill-column.
(defadvice set-fill-column (after fill-column-indicator)
 (when (and ad-return-value
            fci-mode)
   (fci-mode 1)))

;;; Functions that Set and Unset the Rule

(defun fci-delete-overlays-region (start end)
 (mapc #'(lambda (x) (if (eq (overlay-get x 'category) 'fci)
                         (delete-overlay x)))
       (overlays-in start end)))

(defun fci-put-overlays-rule (start end)
 (goto-char start)
 (let (o)
   (while (search-forward "\n" end t)
     (goto-char (match-beginning 0))
     (setq o (make-overlay (match-beginning 0)
                           (match-end 0)))
     (overlay-put o 'category 'fci)
     (if (< (current-column) fci-column)
       (overlay-put o 
                    'before-string
                    (concat fci-cursor-space
                            (make-string (- fci-column 1  (current-column)) 32)
                            fci-rule))
       (if (= (current-column) fci-column)
              (overlay-put o 'before-string fci-cursor-rule)))
     (goto-char (match-end 0)))))

(defun fci-put-overlays-shading (start end) 
  (goto-char start)
  (let (o)
    (while (search-forward "\n" end t)
      (goto-char (match-beginning 0))
      (if (< (current-column) fci-column)
          (progn
            (setq o (make-overlay (match-beginning 0) (match-end 0)))
            (overlay-put o
                         'before-string
                         (concat fci-cursor-space
                                 (make-string (- fci-column (current-column) 1) 32))))
        (move-to-column fci-column)
        (setq o (make-overlay (point) (match-end 0))))
      (overlay-put o 'face 'fci-shading)
      (overlay-put o 'category 'fci)
      (goto-char (match-end 0)))))  

(provide 'fill-column-indicator)

;;; fill-column-indicator.el ends here
