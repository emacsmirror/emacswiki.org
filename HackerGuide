This is a detailed overview of the Emacs source code, focusing on the [https://git.savannah.gnu.org/cgit/emacs.git/tree/ the master branch].


== Prerequisite: GNU Autotools == 

Emacs --like a lot of GNU projects-- uses the [https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html GNU Autotools], which are used to create the [https://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html GNU Build System], which in turn allows one to finally build Emacs (or other software).

The GNU Autotools is made up of [https://www.gnu.org/software/automake/manual/html_node/index.html Automake], [https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.72/html_node/index.html Autoconf], and [https://www.gnu.org/software/libtool/manual/html_node/index.html Libtool], along with [https://gcc.gnu.org/ GCC, the GNU C Compiler] and [https://www.gnu.org/software/gnulib/manual/html_node/index.html gnulib].  

GNU has more details about the Autotools in their [https://www.gnu.org/software/automake/faq/autotools-faq.html#What-are-the-_0060_0060Autotools_0027_0027_003f FAQ].


== The / directory ==

This contains several scripts, text files, and subdirectories containing the source code for Emacs.   

=== Text files ==

The text files provide a great deal of information about building Emacs, and should be your first stop.  In particular:

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL INSTALL] and [https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL.REPO INSTALL.REPO] --- instructions on installing the source from a tarball and the git repository, respectively.

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/README README] --- an overview of the repo and it's contents.

* The CHANGELOG.n files, where N=some number, provide a rolling account of changes to the source code.  [https://git.savannah.gnu.org/cgit/emacs.git/tree/ChangeLog.4 ChangeLog.4] documents all the changes leading up to the release of v30.1 (February 2025).  [https://git.savannah.gnu.org/cgit/emacs.git/tree/ChangeLog.5 ChangeLog.5] starts the notes for any changes for the 30.1 release.

=== Build scripts ==

The scripts allow you to build Emacs.  They are, in approximate order of use:

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/autogen.sh autogen.sh] --- script that checks you have the right versions
                 of autotools to build the <code>configure</code> script.  It generates the <code>configure.ac</code> script and associated helpers.

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/configure.ac configure.ac] --- is the input used by Autoconf to
                construct the <code>configure</code> script.

* Note that the above-mentioned configure script - executed by typing <code>./configure</code> in the terminal - isn't generated until <code>autogen.sh</code> and <code>configure.ac</code> are run for the first time on your local computer.

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/config.bat config.bat] --- Configuration script for MSDOS machines.


* [https://git.savannah.gnu.org/cgit/emacs.git/tree/Makefile.in Makefile.in] --- a template used by the <code>configure</code> script to create a <code>Makefile</code>.  It isn't generated until <code>./configure</code> is run.

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/GNUmakefile GNUMakefile] --- this is a Makefile that allows you to build Emacs without first configuring it via the <code>configure</code> script.

* [https://git.savannah.gnu.org/cgit/emacs.git/tree/make-dist make-dist] --- this is a shell script which allows you to create a tarball for release.


=== Compilation notes ===

I recommand reading the INSTALL.REPO if you want to build the git
`master' branch. Basically, if you have all dependancies to build the default
Emacs, run:

<pre>
$ make # does the needed autogen, configure, make with default settings
$ ./src/emacs -Q # run it!
</pre>

I recommend using <code>-jPROC</code> flag for make where <code>PROC</code> is the number of CPU
core you have in order to speed up the compilation.

== Emacs core ==

The core of Emacs is written in C.

* <b>lib</b> --- Source of some libraries used by Emacs
* <b>lib-src</b> --- Source of external utilities (etags, hexl, ...)
* <b>src</b> --- Source of the Emacs executable

=== Lisp objects ===

Let's look at <code>src/lisp.h</code> for fundamental definitions.

A Lisp object (<code>Lisp_Object</code>) is basically a number (an integer). For 32bits Lisp_Object, in hexadecimal:

0xAAAAAAAB


This number is split in 2 parts in terms of bits:
* a value (A), length is the number of bits in type minus number of tag bits
* a tag (B), length is 2 or 3 bits

The value is either a memory address or an integer i.e. the <code>fixnum</code>
Lisp type. The tag indicates the type of the value.

On my 64bit build of Emacs, a Lisp object is stored on a 64bits
signed integer which is called (typedef'ed to) <code>EMACS_INT</code>.

Everytime an object is allocated its address is aligned to 8
bytes. That way the 3 least significant bits are always 0 and thus
can be used for the tag. The allocation code is in <code>src/alloc.c</code>.

The tag is 3 bit long and thus can have 8 different values. The value
uses the remaining bits. Integers use another 1 bit of the 3 tag bits.

This technique makes integer handling fast but has the downside of
limiting the available range of integers. This is problematic on
32bit systems where the point in a buffer can't go past a 2^28
(256MB).

=== Lisp types ===

See <code>enum Lisp_Type</code> in <code>lisp.h:472</code>. It's the value of each tag.

* Integer
* Symbol
* String
* Vector-like
* Cons
* Float

Two objects are equal (with <code>EQ(a, b)</code>) if both their <code>Lisp_Object</code>
values are equal.

There are several macros defined to extract the relevant data from a
<code>Lisp_Object</code>.

* <code>XTYPE(x)</code> returns the tag (<code>enum Lisp_Type</code>)
* <code>XINT(x)</code> returns the <code>EMACS_INT</code> value
* <code>XUINT(x)</code> returns the <code>EMACS_UINT</code> value
* <code>XCONS(x)</code> returns a <code>struct Lisp_Cons*</code>
* <code>XVECTOR(x)</code> returns a <code>struct Lisp_Vector*</code>
* <code>XSTRING(x)</code> returns a <code>struct Lisp_String*</code>
* <code>XSYMBOL(x)</code> returns a <code>struct Lisp_Symbol*</code>
* <code>XFLOAT(x)</code> returns a <code>struct Lisp_Float*</code>
* <code>XMARKER(x)</code> returns a <code>struct Lisp_Marker*</code>
* <code>XOVERLAY(x)</code> returns a <code>struct Lisp_Overlay*</code>
* <code>XSAVE_VALUE(x)</code> returns a <code>struct Lisp_Save_Value*</code>
* <code>XPROCESS(x)</code> returns a <code>struct Lisp_Process*</code>
* <code>XWINDOW(x)</code> returns a <code>struct window*</code>
* <code>XTERMINAL(x)</code> returns a <code>struct terminal*</code>
* <code>XSUBR(x)</code> returns a <code>struct Lisp_Subr*</code>
* <code>XBUFFER(x)</code> returns a <code>struct buffer*</code>
* <code>XCHAR_TABLE(x)</code> returns a <code>struct Lisp_Char_Table*</code>
* <code>XSUB_CHAR_TABLE(x)</code> returns a <code>struct Lisp_Sub_Char_Table*</code>
* <code>XBOOL_VECTOR(x)</code> returns a <code>struct Lisp_Bool_Vector*</code>

There's a bunch of type predicates macros:

* <code>INTEGERP(x)</code> checks for float or int
* <code>NILP(x)</code>
* <code>SYMBOLP(x)</code>
* <code>STRINGP(x)</code>
* <code>CONSP(x)</code>
* <code>FLOATP(x)</code>
* <code>VECTORP(x)</code>
* <code>BIGNUMP(x)</code>
* <code>NUMBERP(x)</code>

* <code>PROCESSP(x)</code>
* <code>WINDOWP(x)</code>
* <code>TERMINALP(x)</code>
* <code>SUBRP(x)</code>
* <code>BUFFERP(x)</code>
* <code>FRAMEP(x)</code>

* <code>VECTORLIKEP(x)</code>
* <code>OVERLAYP(x)</code>
* <code>MARKERP(x)</code>
* <code>SAVE_VALUEP(x)</code>
* <code>IMAGEP(x)</code>

=== Pseudovector types ===
Due to having limited available tag space, most Lisp_Objects are internally
represented as vector-like objects.  These objects are tagged structs each
containing a <code>union vectorlike_header</code> at the beginning (which
stores tag and type information), a section composed of Lisp_Objects, and
a section optionally containing miscellaneous information.  Here is a typical
Lisp_Vectorlike struct:
<pre>
struct xyzzy
{
  /* This is our vectorlike header */
  union vectorlike_header header; 
  /* A few Lisp_Object fields follow */
  Lisp_Object foo;
  Lisp_Object bar;
  /* Miscellaneous fields follow */
  int baz;
  void *quux;
}
</pre>
Lisp_Vectorlike types are stored in the enum pvec_types, in <code> lisp.h </code>. 
A new type should be created with each new vectorlike.

Lisp_Vectorlikes should be allocated with ALLOCATE_PSEUDOVECTOR, a macro in lisp.h 
which accepts the C type of the pseudovector, the name of the last Lisp field in 
the pseudovector, and the pvec_type of the pseudovector.  Assuming that PVEC_XYZZY
is the pvec_type of the pseudovector, a typical make_xyzzy function would read:
<pre>
struct xyzzy *
make_xyzzy (Lisp_Object foo, int baz, void *quux)
{
  struct xyzzy *retv = ALLOCATE_PSEUDOVECTOR (struct xyzzy, foo, PVEC_XYZZY);
  retv->foo = foo;
  retv->bar = Ffoobar (foo);
  retv->baz = baz;
  retv->quux = quux;
  return retv;
}
</pre>
To convert between the returned struct, and the corresponding Lisp_Object, a
common idiom is to define a macro in lisp.h, that invokes the macro XSETPSEUDOVECTOR,
which sets the field <code>a</code> to the Lisp_Object representation of the pseudovector
<code>b</code>.  For example:

<pre>
#define XSETXYZZY(a, b) XSETPSEUDOVECTOR (a, b, PVEC_XYZZY)
</pre> 

When creating pseudovectors, a new switch clause should be placed in <code>print_vectorlike</code>
(a C function in print.c), which prints a textual representation of the Lisp_Vectorlike.  For our
hypothetical xyzzy object, a typical entry would read:
<pre>
static bool
print_vectorlike (Lisp_Object obj ... Lisp_Object printcharfun ...)
{
  switch (PSEUDOVECTOR_TYPE (XVECTOR (obj))
    {
       ...
    case PVEC_XYZZY:
      print_c_string ("#<xyzzy>", printcharfun);
      break;
    }
}
</pre>
=== Defining functions ===

There is a <code>DEFUN</code> macro in <code>lisp.h:1987</code>. Have a look at the manual,
it's pretty well written. [[Manual:Writing Emacs Primitives]] (elisp)

=== Idioms ===

==== Iterating on a list ====

<pre>
Lisp_Object tail;

for (tail = list; CONSP (tail); tail = XCDR (tail))
  {
    List_Object e = XCAR (tail); /* current element */
    /* ... */
  }
</pre>

=== Configure script and build flags ===

If you know how to write basic shell scripts you're good to go. This
is a crash course in autoconf for Emacs. Have a look at autoconf doc
for more.

==== Adding a enable/disable configure flag ====

Open <code>configure.ac</code>, it's a big shell script template
that is processed by autoconf to generate the actual configure.sh
script.

Look for <code>OPTION_DEFAULT_ON</code> or <code>OPTION_DEFAULT_OFF</code>
depending on if you want your option to be turn on or off by default.

The syntax is <code>OPTION_DEFAULT_ON([thing],[description])</code> where:
* <code>thing</code> is the thing you want to turn on or off (<code>--with-thing</code>, <code>--without-thing</code>)
* <code>description</code> is a description of the thing.

This macro will define a <code>with_thing</code> shell variable
available in the rest of the script. Its value will be either "yes" or
"no".

The convention is later in the script:

* To first to check if <code>$with_thing</code> is <code>yes</code>
* In which case you check if you can actually enable it for emacs on the current system
* If that's the case, set a <code>HAVE_THING</code> variable to yes. If you can't enable it, set it to no.
* Add the corresponding <code>echo</code> close the the end of the script. Look for "Does Emacs use" in <code>configure.ac</code>.

==== Exporting a C macro ====

If you need to export something to make it available in the C sources
(as a define macro written in <code>src/config.h</code>), use:

<pre>
AC_DEFINE(YOUR_MACRO, value, [Purpose of the macro])
</pre>

This will define <code>YOUR_MACRO</code> to the verbatim
<code>value</code>. In case you want to export the content of a shell
variable (expand it), simply putting <code>$value</code> <b>will not
work</b>, you have to use:

<pre>
AC_DEFINE_UNQUOTED(YOUR_MACRO, "$your_variable", [ description ])
</pre>

==== Exporting a shell variable to rest of autoconf machinery ====

If you need to export a shell variable to <code>src/Makefile.in</code>
(the file that is processed by autoconf to generate the actual
Makefile) you need to use

<pre>
AC_SUBST(YOUR_SHELL_VAR)
</pre>

This will replace any occurence of <code>@YOUR_SHELL_VAR@</code> in
files processed by autoconf with the content of the shell var. If you
look at src/Makefile.in for example, you can see:

<pre>
LIBZ = @LIBZ@
</pre>

This define a Makefile variable to the value of the shell variable
defined earlier in <code>configure.ac</code>.

==== Summary ====

<pre>
# first define the configure option
OPTION_DEFAULT_ON([thing],[description])

# ...

# Thing support
HAVE_THING=no
## declare here other variable you need
## like additional build flags, etc.
##
## the convention is to use
##  - THING_OBJ for additional object files (use AC_SUBST to export!)
##  - LIBTHING for additional librares to add to the linker flags (use AC_SUBST to export!)

if test "${with_thing}" != "no"; then
 # do your check to see if you can actually enable it
 HAVE_THING=yes # (lets assume you can)
 # define
fi

if test "${HAVE_THING}" = yes; then
  # now you *have* to enable Thing!
  # AC_SUBST, AC_DEFINE, etc usually go here
  AC_DEFINE(HAVE_THING, 1, [Define to 1 if Thing enabled])
fi

# ...

# add a "summary line" printed at the end of configuration
echo "  Does Emacs has Thing?                 ${HAVE_THING}"
</pre>
