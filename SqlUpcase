A minor mode which converts lower-case SQL keywords to upper-case as you type or otherwise insert text in the buffer -- for instance, killing and yanking an entire SQL query would upcase all keywords in that query.

Commands are also provided for upcasing all keywords in the buffer (`sql-upcase-buffer'), or a specified region (`sql-upcase-region').

The library utilises the product-specific regexps defined by SqlMode, and thus will upcase only the keywords defined for the buffer's `sql-product'. (Note that `sql-mode' buffers default to the `ansi' product. See also SqlQueryBuffer.)

==Download==

Download the library from Lisp:sql-upcase.el

==Install==

Place the library somewhere in your Emacs load-path (or use ##M-x package-install-file## for the downloaded file), and add the following to your init file:

 (when (require 'sql-upcase nil :noerror)
   (add-hook 'sql-mode-hook 'sql-upcase-mode)
   (add-hook 'sql-interactive-mode-hook 'sql-upcase-mode))

Or, with use-package (built-in Emacs 29 or later):

 (use-package sql-upcase :ensure nil
   :commands sql-upcase-mode sql-upcase-region
   :hook (sql-mode sql-interactive-mode))

==Configure==

By default, /only/ lower-case keywords are processed. ##(setq sql-upcase-mixed-case t)## to handle mixed-case keywords as well.

==Known issues==

# This is slightly aggressive in `sql-interactive-mode', in that text insertions in that mode are not always typed by the user. The biggest concern /is/ handled -- output from the inferior comint process is not touched. However there may be other cases (e.g. cycling through the comint command history) in which automatic modifications to the inserted text are less desirable. In practice this is probably ok, but YMMV.

# It is assumed that font-lock patterns using `font-lock-builtin-face' are functions, and should only be upcased when followed by an opening parenthesis. In practice this is not always accurate (an example being that, for PostgreSQL, ##set## is treated as a 'builtin' rather than a 'keyword'). It may be better to treat both types the same, and not insist upon the opening parenthesis for builtins, but more investigation is needed.

# Contextual behaviour is limited to ignoring comments and strings, so if you have an identifier name in your query which is also a keyword, it will be upcased. If an unwanted upcasing occurs, you can use undo to revert to the original case.

# Unbalanced quotes in a sql-mode buffer prior to the current statement could confuse the code which checks whether a potential keyword is actually part of a string. This could perhaps be improved by using `sql-beginning-of-statement', but it's neither clear to me that that command is robust enough for non-interactive uses, nor that the /general/ question of establishing the (outer) beginning of a SQL statement without parsing it is even possible when it may be preceded by arbitrary content. For instance, the actual query might easily appear as the sub-query of some incomplete SQL earlier in the buffer. Narrowing the buffer to the query you are actually editing should be a workaround for any such issues, however. (Note that in SQLi buffers we use the prompt to constrain these syntax checks, which should be fairly reliable.)

----
CategoryModes
CategorySql
