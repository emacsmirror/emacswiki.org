Documentation, current as of 2023, on fsbot, an irc bot that hangs out in #emacs on libera.
The bot is called fsbot. The software is called erbot. 
Fsbot ("free software bot") is an infobot that has supported several free software channels on irc since c. 2001.


(Please don't change the design or contents of this document, except for minor cleanup. -deego).


== Parsing/Lispification and Lisp interpreter ==

At its core, fsbot is an infobot - it allows you to add notes for terms, and spits out the notes when requested.

To set the **notes** for new **term** "myterm" to "my notes", you can type one of three things: (1) ##,myterm is my notes## (2) ##,(fs-set-term "myterm" "my notes")##, or finally, (3) ##,(set-term "myterm" "my notes")##. (1) is referrred to as a natural-language- or English- syntax. (2) is the lisp form, and finally, (3) shows that if the `fs-' prefixes are omitted, a codewalker adds them right back. Internally, all three expressions eventually convert to form (2) which then converts to ##(fsi-set-term "myterm" "my notes")## before actually getting executed. 

You often use the easiest paren-free English syntax to command the bot, but as is inevitable with any NL-parsing, you will eventually run into ambiguities, edge-cases and conflicts. Your best option in such cases is to use the precise lisp syntax for more fine-tuned control. But, you shouldn't have to remember the equivalent lisp-form. You should simply be able to look it up! You simply ask the bot itself via ##(fs-parse)## which is also aliased to ##(fs-lispify)##: 

    <deego> ,(parse "Emacs is a good editor")                                                                                                                                                  
    <fsbot> (fs-set-term "Emacs" "a good editor")


This tells you that a sentence of the form "foo is bar" gets parsed into an `fs-set-term' form. So far, the bot has merely parsed the command, not actually executed it. 
Next, you actually execute the command and tell the bot that Emacs is a good editor:

   <deego> ,Emacs is a good editor                                                                                                                                                          
   <fsbot> Created new note for "Emacs"

As should be clear by now, you could have also used the lisp-form to effect the above:

    <deego>  ,(set-term "Emacs" "a good editor")
    <fsbot> Created new note for "Emacs"                     


This sets the term, persistent across sessions, in the publicly available file **botbbdb**.

An additional note for an existing term is entered via "is also" whose parse is:
 
  <deego> ,(parse "Emacs is also a great OS")                                                                                                                                          
  <fsbot> (fs-set-also "Emacs" "a great OS")


As we mentioned, for convenience, you can skip the `fs-' prefix when commanding fsbot, and it is always automatically added for you. Thus, instead of having to type ##(fs-parse ..)##, you were able to simply type ##(parse...)##.

Let's assume we added 11 more notes for the term "emacs." Now, how do we read them off? Just say emacs! - 

  <deego> ,emacs
  <fsbot> emacs is [0/12] an extensible, customizable, self-documenting real-time display editor <http://www.gnu.org/software/emacs/>
  <fsbot> [1] began as a set of macros for the TECO editor in 1976 by gls and rms
  <fsbot> [2] frustratingly inadequate, but often better than any extant alternative (see ,salespitch)
  <fsbot> [3] heavily optimised to navigate its own code ;;[ ,more / ,dump]

There's a bunch of other functionality available to manipulate terms, notes, their order, merge/cp/rm terms, etc., but let's move on to the next topic.




As we saw above, the bot understands and executes a restricted and modified subset of lisp we refer to as **fslisp**. Furthermore, it sandboxes everything to ensure we internally always stay in the `fs-' namespace. These `fs-' functions and macros use various codewalkers, are carefully designed to avoid the irc user being able to do things like ##(shell-command "rm -rf /")##, ##(eval '(kill-system))##, etc, and are therefore sometimes very different from their usual emacs counterparts. Another source of difference arises because they were written with bot-related functionality in mind. For example, `fs-replace-string' is used to replace strings within the notes of terms, and is thus very  different from the usual `replace-string' found in emacs.

*Building blocks:* You have about 1000 such `fs-' commands available, referred to as **botcommands**. Internally, some botcommands are macros and some are functions. These include some powerful building blocks like `fs-while', `fs-mapcar' and cousins, `fs-eval', `fs-read', `fs-error', `fs-setq' and `fs-makunbound', `fs-apply', `fs-funcall', `fs-quote', `fs-lambda', etc.  


Among those included are `fs-defun', `fs-fmakunbound', and `fs-defalias'. In other words, you can build upon the initial botcommands and create - or remove - as many more as you like.

Thus, you have read/write access to the `fs-' space. This rw access applies to all new functions you create, but not to the initial core `fs-' functionality, which has read-only access. Thus, trying ##(fmakunbound 'fmakunbound)## - equivalently  ##(fs-fmakunbound 'fs-fmakunbound)## - will lead to an error because `fs-fmakunbound' is part of the core functionality. Such core functions should behave in a consistent fashion, for everyone to use, and should not change just because some irc user changed them via a PM. Another example of a **core botcommand** is `fs-set-term'.


You can query and search among the ~ 1000 bot-commands available to you using `fs-commands':


    <deego> , (commands "^a")
    <fsbot> 7 matches.  (a ac and append apply apropos av)

This means that you have access to the following bot commands that start with the letter a: `fs-a', `fs-ac', `fs-and', `fs-append', etc.

This was, in essence, an apropos-search, but restricted to items with the prefix `fs-'. A related command is fs-apropos. It searches over all emacs functions/variables, no longer restricting to the `fs-' prefix:

    <deego> , (apropos "^ac")
    <fsbot> 11 matches.  (acapulco accept-process-output access-file
        accessible-keymaps ache aching acid acons acos
        activate-input-method active-minibuffer-window)


Since you have access to `fs-defun' and `fs-setq', you can define your own `fs-' functions and set your own `fs-' variables. Once defined, these remain persistent across sessions. These are referred to as **userfunctions** and **uservariables**, respectively, and get stored in the publicly available files **userfunctions.el** and **uservariables.el**. /Uservariables should not be confused with terms/, which are set via `fs-set-term', as illustrated earlier. 




=== Some notes on the parser === 

Internally, things get pretty complex. For example, ##(fs-apply SUBJECT arg1, ... , argn, arglist)## is fairly complex because it has to handle all kinds of cases in the secure `fs-' model: the subject could be a variable, a lambda, a quoted lambda, a quoted symbol, etc. The args could be variables, or literals. Additionally, of course, either can be other (fs)lisp-expressions that result in any of the aforementioned possibilities. Among other things, in each case, the codewalkers need to ensure that we don't allow jailbreaking out of the `fs-' namespace.  


Here's another reminder that everything you do is actually happening in the `fs-' space. When you  ##,(defun increment (myvar) (+ 1 (apply 'myfun myvar)))##, it first internally gets parsed as ##,(fs-defun fs-increment (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. That works because `fs-defun', `fs-apply', and ##`fs-+'## are functions/macros that are provided to you in the core functionality, and because you hopefully already `defun'd a `fs-myfun' prior to this. Notice how the parser figures out that it needs to prefix the quoted expression as well. It converts `myfun' to `fs-myfun'. (If it didn't, you would be able to jailbreak to access things like ##'shell-command##). 

In some contexts, however, quoted expressions should *NOT* be prefixed with `fs-'. When you type ##,(format "%s" 'a)##, you expect the answer to be "a", and indeed, the parser correctly figures out that it should NOT, in this case, convert ##'a## to ##'fs-a##.

`fs-parse' is idempotent; this equality holds: (equal (parse foo) (parse (parse foo)). Thus, other than the fs-prefix codewalker, lisp-expressions stay unaltered after parsing.


=== Context-dependent parse of NL syntax ==


While the lisp parser is pretty stable and reliable, the english parser is anything but. The latter is heavily context-dependent. For example, 
##,describe foo## gets parsed as ##,([fs-]describe "foo")##  but ##,foo is bar## gets parsed as ##,(set-term 'foo 'bar)##. Furthermore, the latter would get parsed as ##(foo 'is 'bar)## if a user-function foo existed. The English parser also evolves with time, at the whim of the author, to try to make fsbot more DWIM-my. This context-dependence is regarded by the author as a feature, not a bug. If that is a problem, please try using the lisp syntax instead. English sucks as a programming language. That's why you also have lisp at your disposal.

Here's an incomplete list of factoids related to the NL parser. The list below is mostly in chronological order. That is, the parser essentially goes down this list, till something matches.

* As you have already seen, a leading comma is equivalent to addressing and invoking fsbot. Thus, these two are equivalent: ##fsbot: tell me about Emacs## and ##, tell me about Emacs##.

* When it makes sense (that is, when a function fs-foo exists), the NL parser tries to parse ##, foo bar baz.. ## as a funcall:  ## (foo BAR BAZ..)##, where BAR and BAZ are the results of (read) on bar and baz, respectively. This one rule automatically leads to a lot of usage commanly seen: the invocation of ##,more##, ##,gpt## , ##,google##, ##,describe##, ##,find-function##, ##,flame##, ##,rr##, ##,kick##, etc. This rule, for example, is what leads to ##<deego> fsbot: + 1 2 3## resulting in ##<fsbot> 6 ..(integer)##. This rule is what leads to fsbot kicking the intended party when you type ##,kick me##. This is why ##,commands ^a## dtrt and lists all botcommands starting with a.

* As already seen, ## foo is [also] bar baz... ## is parsed as adding notes ##bar baz..## to the term ##foo##. That is, sentences of these forms are converted to ##(set-term..)## or ##(set-also..)##

* Several other special English forms are supported in a similar vein. Example: ##,tell [nick] about [topic]##. That is, such forms convert to ##(tell-to ...)##

* When nothing else matches, ##,foo## is parsed as ##,(describe "foo")##. That is, it tries to look up the notes for a term foo. If a term ##foo## exist, that command also searches for ##*foo*##. Several niceties are built in within that. Example: ##,foo bar-baz flu## will search for, among other things, .*foo.*bar.*baz.*flu. ##,foo.*baz## is understood to be a regexp search. If fsbot doesn't find a matching term, then, it also searches the notes of the terms. That is, it invokes the equivalent of ##(search ..)## and ##(search-wide ..)##.

* To invoke fsbot mid-sentence, use a double-comma. Example: 
    <rk1>: How do I customize my Emacs starting behavior? 
    <msp>: You should read up on ,,init


Here msp is replying to rk1, while also but commanding fsbot to output the notes for the term ##init##. As far as fsbot is concerned, msp has typed ##fsbot: (describe "init")##. Therefore, following msp's reply to rk1, 

* A second double-comma ends the fsbot-invocation. Example, msp might have responded to rk1 by saying:

    <msp>: Why don't you read up on ,,init,, and then get back to us? ##

Again, fsbot sees ##,(describe "init")##, and follows msp's reply with the description of ##init##.






  


=== `fs-' stripping ===
The definition of `fs-increment' that you just created is built upon several other `fs-' functions. As we alluded to above, you can immediately see your new function in the publicly available file userfunctions.el. Or you can ask fsbot to `find-function' the function for you and return a pretty-printed output. When you type ##,(find-function 'fs-increment)##, fsbot will return a readable version of the definition, by stripping all the `fs-' prefixes. Thus, when you see the bot returning this definition: ##(lambda (myvar) (+ 1 (apply 'myfun myvar)))##, keep in mind that's just a readable shorthand for ##(lambda (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. The former does not always equal the latter. Fsbot's output is readable but inaccurate if taken literally. If you want the bot to retain the `fs-' prefixes when printing the definition, you can use other botcommands such as `find-function-literally' or `ffl'.


=== More on fs-find-function ===
##(fs-find-function 'foo)## first looks for an emacs function `foo', and when that doesn't work, it looks for a userfunction `fs-foo'. Thus, provided a built-in `foo' does not exist, you can use `foo' to refer to `fs-foo' when using fs-find-function. `fs-ff' is an alias for `fs-find-function'. Putting all these shortcuts together: You will often see #emacsers typing the English-form ##,ff myfun## instead of the more verbose form ##,(fs-find-function 'fs-myfun)##. The English form gets parsed as ##(fs-find-function 'myfun)##, which initially looks for `myfun', falls back upon `fs-myfun', and eventually returns the `fs-' stripped definition of `fs-myfun'. You will find similar shortcuts and fallbacks in many other botcommands, meant to promote convenience and brevity. Here's another example: `ff' actually has yet another fallback: it punts to `fs-find-variable' when the latter is expected to work. That arose because far too often, I noticed people trying `ff' when they actually meant `fv', which is a shortcut for `fs-find-variable'.


== GPT interface ==

**Please note that your that input that invokes chatgpt does *not* become part of openai's training corpus.**

The recommended way to invoke GPT is to use ##!## or ##,g##  when talking to the bot.
These special handlers take care of quoting the rest of your input properly, and passing it verbatim.
 
    <deego> ! which is the world's tiniest editor (((" ? 
    <fsbot> The world's tiniest editor is probably "Micro Emacs" or "µemacs", which is a compact text editor designed for Unix-like operating systems

Notice that the gibberish at the end of the text did not, in this case, cause problems. Normally, such gibberish would be passed through fsbot's read feature and lead to an error, but that feature is disabled for the above three special handlers. The read feature is otherwise useful for most other bot functionality, for example, when you simply type ##,+ 1 2##. 





== Interaction History, logging and trash: ==

*Summary*: Use ##,history## for your private session-history. ##,dump## to dump previous interactions, ##,trash*## to see undo-information, and ##,botlog## to see everyone's rw changes. 


*Interaction:* Every interaction with the bot is logged via multiple logging mechanisms, detailed below. (The full record of) an *interaction* refers to the set {your command, its parse, the bot's response, and finally, any *undo-information* it generated}. Each interaction is assigned a random, unique name.

*Privacy:* Every interaction, especially when *rw*, enters a permanent, public record on the web. Please plan accordingly! Though *ro* interactions are somewhat semi-private to you, as explained below, I can make no guarantee of privacy even for this case. 

*ro* and *rw*: *rw* refers to an interaction that attempts to make any changes to the bot database, set any term or alter any functions or variables  (even temporarily.).  *ro* refers to other interactions that merely query a bot for information.

*Logtmp:* Every interaction generates a temporary log, available in an unlisted url under the logtmp/ folder.  These logs are subject to periodic deletion. 

*History:* When /query-ing the bot, ##,history## will list all your previous commands along with the name assigned to the corresponding interaction-record. In a channel, it lists a history of the entire channel's interactions, irrespective of the author. To dump the full record, use ##,dump##.

*Dump:* ##,dump N## will dump the n'th-oldest interaction. ##,dump <partial-name>## is another way to dump the interaction, where the name was looked up via typing ##,history##.

*Logfull:* rw interactions also get listed under the logfull/ folder. Unlike logtmp, these logs are permanent. As mentioned above, the record includes all undo-information.

*Botlog:* Also available in the botlog/ folder on the web. ##,botlog N## will dump a list of all rw interactions on day #(today - N). This includes every single rw change, made by any user, on any channel. Every interaction will also include a pointer to its logfull-record.

*Undo:* Every rw interaction's record also includes an *undo* entry: enough information to reconstruct the original database. This information becomes part of a permanent public record on the web. It also gets stored in the *trashcan*.


*Trashcan:* While all undo-information is part of a permanent public web record, it is also stored in the bot's db temporarily via a trash-mechanism. A *trash-term* is simply a term that starts with "FsTrash". Whenever any undo-information is created, new trash-term(s) are created. ##,trashlist## returns a list of trash-terms, which can then be queried like any other term. You can then use this information to undo any accidental damage. ##,trashtrash## empties the trashcan; that is, it deletes all terms starting with FsTrash.




== Extended English interface using triple-comma ==
(New, in 2023, under construction.)

You want fsbot to output its notes about the term "emacs." Or, just list its notes 3 through 6.

Or, you want to swap the term "emacs" with "vi."

Or, cp the term emacs to elisp.

Or, rename the term elisp to emacs_lisp

Or, forget the tenth note for "emacs."

Or, add a new note for "emacs."

Or, create a new term "elisp."

Or, tell <nick> about the fifth note of emacs. 

Or, move the third note of emacs to the 2nd position.

I always see people struggling, especially with that last case.  Do you always remember the English syntax for that?  ## ,3->2 in emacs ##,  or its equivalent lisp parse: ##, (rearrange 3 2 "emacs")## ?  Of course not! Well, just command the bot using whatever portion of the syntax you remember, using the shiny, new ##,,,##  If you don't remember the syntax at all, even plain English can often work:

   <deego> ,,, move the thiird note of emacs to the 5th postition                                                                                                                       
   <fsbot> Moved note 3 to 5 in "emacs"

It worked, even though I made two typos!

And, of course, once again,you can also access the extended parser itself: 

    <deego> ,(gparse "will you please merge the term emacs with elisp")
    <fsbot> (merge "emacs" "elisp")




== Google ==
To invoke google, type ##,gg## or ##,goog## or ##,google##. 
##,gge fsbot## is equivalent to ##,gg site:emacswiki.org fsbot##.
##, gg 2 fsbot emacs## will return the top two google results for ##fsbot+emacs## 

If you wish to pass on double-quoted arguments to google, it's best to use the lisp syntax.
Example:

    <deego> ,(google 1 "\"richard stallman is just my mundane name\"")
    <fsbot> https://www.cs.mcgill.ca/~rwest/wikispeedia/wpcd/wp/r/Richard_Stallman.htm
    <deego> ,(google 1 "\"richard stallman is my just mundane name\"")
    <fsbot> ""  ..(string)
Notice that the second request returned no results.


== Other minor features ==

erbot has many other features developed over 20+ years of irc usage. New ones come and go. Some fall into disuse. The best way to learn them is to just start using fsbot and see how people use them on #emacs. Here's a partial list.

* redirect terms
* tell foo about bar
* karma
* praise
* flame, spook, doctor, yow, fortune, fact (rms), geek-code
* A sandboxed octave evaluator, usually disabled in fsbot. It tries to make the input safe before executing it, but almost surely has some obscure security holes.
* A plurality detector.
* Dvorak/colemak/qwerty battle
* A dunnet player
* An interface to wtf
----

ErBot

