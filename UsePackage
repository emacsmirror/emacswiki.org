[[https://github.com/jwiegley/use-package use-package]] is a declarative way to load packages in your init.el. 

use-package aims to decrease Emacs startup time by loading packages *on use* rather than *on startup*

: I have over 80 packages and things were getting difficult to manage. With this utility my total load time is around 2 seconds, with no loss of functionality!

use-package is included as of Emacs 29.1

== Configuration ==

* [[https://www.gnu.org/software/emacs/manual/html_mono/use-package.html See the Manual]].
* [[https://github.com/jwiegley/use-package/blob/master/README.md See the README]].
* See ##M-x define-function use-package##.

A simple ##use-package## declaration may look like:

{{{
(use-package dired-x)

(use-package dired
  :bind (("C-c d" . dired-jump)
	 :map dired-mode-map
	 ("/" . dired-omit-mode)
	 ("h" . dired-hide-details-mode)
	 ("-" . dired-up-directory))
  :hook '((dired-hide-details-mode)
	  (dired-omit-mode))
  :config
  (setq
   dired-x-hands-off-my-keys nil
   ls-lisp-dirs-first t ;sort dirs first
   ls-lisp-use-insert-directory-program nil))
}}}

It customizes [[Dired]]. With this configuration, ##dired## and its configuration are *not loaded* until ##dired## is called.

The syntax used in this example is explained below:

{{{
(use-package package-name
  :bind   -- A list of global keybindings
    :map  -- A list of local  keybindings
  :hook   -- A list of hooks
  :config -- Variables to set after the package is loaded
}}}

== An older package named use-package ==

There is another older (last edited 2007) use-package: Lisp:use-package.el. 
It is a combined installer and configurer, which defines an
"autofetch" (like autoload, but downloading from the network -- or
other media) and also conveniently sets up various things it's useful
to have on eval-after-load forms.

Its entry point is the macro use-package; you might also want to use autofetch in its own right.

This lets you write package descriptions such as:

    (use-package vm
		 nil                        ; download to default directory
		 (nil                       ; use default getter function
		  "http://www.seanet.com/~kylemonger/vm/vm-7.19.tar.gz"
		  ;; after-download form:
		  (shell-command "cd vm-7.19; make"))
		 ;; configuration arg to use-package:
		 ("$COMMON/emacs/email"   ; string means directory for load-path
		  (require 'jcgs-vm-stuff)  ; can add your own aux stuff
		  ([ C-f11 ] . js-vm-get-mail) ; key definitions
		  ([ M-C-f11 ] . vm-continue-composing-message)
		  ;; autoloads/autofetches
		  (vm "vm" "Run the VM mail reader" t)
		  ;; things that look like auto-mode-alist entries are
		  ("~/vm" . vm-mode)
		  ("$COMMON/vm" . vm-mode))
		 ;; remaining args to use-package are eval-after-load forms
		 (setq vm-mutable-frames nil
		       bbdb-completion-type 'primary-or-name
		       read-mail-command 'vm
		       vm-folder-directory (if (file-directory-p
						(expand-file-name "~/vm/"))
					       (expand-file-name "~/vm/")
					     (substitute-in-file-name "$COMMON/vm/"))
		       vm-primary-inbox (expand-file-name "john" vm-folder-directory)))

I find this a handy way for keeping together definitions of how to get
a package, with how to configure it; it's particularly nice when I
arrive on an unfamiliar machine, and can load one startup file from
the web or my USB key drive, and have it pull the rest across as I use
it for the first time on that machine.

The next enhancement will probably be indirect URLs, where it searches
the page at the specified URL, for links whose anchor text matches a
particular pattern -- intended for giving it a downloads page such as
on SourceForge, and picking the URL from that. I'll probably add SHA1/
MD5 verirfication, too. 


[new]
See also [[el-get]] -- dim
