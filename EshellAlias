An Alias is a short "nickname" for a longer command. You can define your own aliases in Eshell.

See also EshellFunctions for more elaborate examples.



== Defining Aliases ==

=== Using 'defalias' ===

In your Init file, you can use the ##defalias## function:

{{{
;; Alias 'open' to 'find file'
(defalias 'open 'find-file)
}}}

A more complex example:

{{{
   (setq my/eshell-aliases
      '((g  . magit)
	(gl . magit-log)
	(d  . dired)
	(o  . find-file)	
	(oo . find-file-other-window)
	(l  . (lambda () (eshell/ls '-la)))
	(eshell/clear . eshell/clear-scrollback)))
     
    (mapc (lambda (alias)
	(defalias (car alias) (cdr alias)))
       my/eshell-aliases)
}}}

=== Using 'alias' from within Eshell ===

    ~ $ alias ll 'ls -l $*'

To alias ##emacs## to ##find-file##:

    ~ $ alias emacs 'find-file $1'

Without the 'quotes', the positional parameter will get lost:

    ~ $ alias emacs find-file $1
    ~ $ alias
    alias emacs find-file

*Note:* ##$*## instead of ##$1## will not work because ##find-file## expects exactly *one parameter*.
Using ##$*## passes a *list* of parameters to find-file

    ~ $ alias emacs 'find-file $*'
    ~ $ emacs test.txt
    Wrong type argument: stringp, ("test.txt")

##$*## will work with the following advice (put it into ##.emacs##):

{{{
(defadvice find-file (around find-files activate)
  "Also find all files within a list of files. This even works recursively."
  (if (listp filename)
      (loop for f in filename do (find-file f wildcards))
    ad-do-it))
}}}

Or the all-eshell version:

    alias emacs 'for i in ${eshell-flatten-list $*} {find-file $i}'

== Permanently Storing Aliases ==

All aliases will be stored automatically, thus you do not need to manually edit any file.

The variable `eshell-aliases-file' defines the file in which aliases are stored. If you edit it by hand, you'll need to refresh eshell's *cache* of values. To do this, run the ##eshell-read-aliases-list## function (which you can do by *typing it in eshell!*)

You also can define new eshell commands in your .emacs file.

{{{
;; Alias 'open' to 'find-file'
(defun eshell/open (file)
  (find-file file))
}}}

This way you can define pretty complicated functions 
using Emacs Lisp.

== Sharing aliases with bash ==
Many people have lines like this in their .bashrc file:
    alias ll='ls -l'
Eshell needs a different syntax:
    alias ll 'ls -l'
To integrate both, either:
* a) eshell accepts bash's syntax
* b) bash reads eshell's alias file
* c) both shells use a new neutral command which defines alias using the right syntax depending on the caller
* d) the user is forced to maintain two files, ideally with a script which can create one from the other

I have used solution d: I use a line in .bashrc which, after all aliases have been defined, creates the alias file for eshell (eshell-aliases-file):

    alias | sed -E "s/^alias ([^=]+)='(.*)'$/alias \1 \2 \$*/g; s/'\\\''/'/g;" >~/.emacs.d/eshell/alias 

This takes care of allowing eventual parameters ($*) and allows single quotes as part of the expanded alias.
That line takes only 0m0.007s so I don't mind running it each time I open bash.

-- 2.m7.2010 [[DanielClemente]]

â€¦ And if you're using zsh, try this cryptic line, it handles all the strange cases with quotes, at least all the ones in my file, and you can debug it by stopping in the intermediate pipes:

    alias | sed 's/^alias //' | sed -E "s/^([^=]+)='(.+?)'$/\1=\2/" | sed "s/'\\\\''/'/g" | sed "s/'\\\\$/'/;" | sed -E 's/^([^=]+)=(.+)$/alias \1 \2/' >~/.emacs.d/eshell/alias

-- 10.m9.2017 [[DanielClemente]]

==Reading directly from ~/.bash_aliases==


    (add-hook 'eshell-mode-hook 'eshell-load-bashrc-aliases)
    (defun re-n-matches ()
      (1- (/ (length (match-data)) 2)))

    ;; from xah-lee http://ergoemacs.org/emacs/elisp_read_file_content.html
    (defun get-string-from-file (filePath)
      "Return filePath's file content."
      (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))

    (defun match-strings-all (&optional string)
      "Return the list of all expressions matched in last search.
      STRING is optionally what was given to `string-match'."
      (loop for i from 0 to (re-n-matches)
    	collect (match-string-no-properties i string)))
      
    (defun re-find-all (regexp string &optional groups yes-props)
      "like python's re.find_all"
      (let (
    	;;(groups (or groups (list (regexp-count-capture-groups regexp))))
    	(match-string-fun (if (not yes-props) 'match-string 'match-string-no-properties))
    	(start 0)
    	(matches nil )
    	)
        (while (setq start (and (string-match regexp string start) (match-end 0)))
    	(setq matches (cons (cdr (match-strings-all string)) matches))
    	)
        (setq matches (reverse matches))
        (if (not (cdar matches))
    	(mapcar 'car matches)
          matches
          )
        )
      )
    
    
    (defun apply-eshell-alias (alias &rest definition)
      "basically taken from eshell/alias function"
        (if (not definition)
    	(setq eshell-command-aliases-list
    	      (delq (assoc alias eshell-command-aliases-list)
    		    eshell-command-aliases-list))
          (and (stringp definition)
    	   (set-text-properties 0 (length definition) nil definition))
          (let ((def (assoc alias eshell-command-aliases-list))
    	    (alias-def (list alias
    			     (eshell-flatten-and-stringify definition))))
    	(if def
    	    (setq eshell-command-aliases-list
    		  (delq def eshell-command-aliases-list)))
    	(setq eshell-command-aliases-list
    	      (cons alias-def eshell-command-aliases-list))))
      )
    (defun eshell-load-bashrc-aliases ()
      (interactive)
      (mapc (lambda (alias-def) (apply 'eshell/alias alias-def))
    	(re-find-all "^alias \\([^=]+\\)='?\\(.+?\\)'?$"
    		     (get-string-from-file  (concat (getenv "HOME") "/" ".bash_aliases"))
    		     )
    	)
      )
    

----

-- 2019-01-24 [[Arthur Miller]]:

I have edited code above - added get-string-from-file and commented away unnecessary line (groups (or ... )))) to make it work on my Emacs, however this is noticeably slow. The solution will neither take into consideration that users might have their aliases spread in
different files, for example if they use something bash-it. Currently as I know the best solution is to export aliases from bash to alias file as suggested in 'sed' snippet.


== Dynamically loading aliases from Bash environment ==
-- 2019-04-01 [[Arthur Miller]]:

I just played with Eshell a bit again, and hacked simple way to load aliases dynamically. Unlike Sed version above
it seems to work much smoother since it asks Bash for the list of currently available aliases instead of parsing .bashrc file. It means that alias changes will be mirrored in Eshell when .bashrc is changed. I also use only temporary buffer, and does not read files at all which seems to be a bit faster as well. Gotcha is that I was too lazy to make it properly (it works well for me). First caveat is that it expects a list of single quoted aliases: 

'''alias md='mkdir'

Also, you can't use something like alias md="mkdir". Second issue is that it expects no white spaces after the alias line ending. So cleanup you bashrc file before you run it or adapt this script to use regular expressions with both quotes and more flexible white spaces.

----

    (require 'eshell)
    
    (defun eshell-load-bash-aliases ()
           "Reads bash aliases from Bash and inserts
    them into the list of eshell aliases."
           (interactive)
           (progn
                   (message "Parsing aliases")
                   (shell-command "alias" "bash-aliases" "bash-errors")
                   (switch-to-buffer "bash-aliases")
                   (replace-string "alias " "")
                   (goto-char 1)
                   (replace-string "='" " ")
                   (goto-char 1)
                   (replace-string "'\n" "\n")
                   (goto-char 1)
                   (let ((alias-name) (command-string) (alias-list))
                        (while (not (eobp))
                           (while (not (char-equal (char-after) 32))
                                  (forward-char 1))
                               (setq alias-name
                                       (buffer-substring-no-properties (line-beginning-position) (point)))
                               (forward-char 1)
                               (setq command-string 
                                       (buffer-substring-no-properties (point) (line-end-position)))
                               (setq alias-list (cons (list alias-name command-string) alias-list))
                               (forward-line 1))
                        (setq eshell-command-aliases-list alias-list))
               (if (get-buffer "bash-aliases")(kill-buffer "bash-aliases"))
               (if (get-buffer "bash-errors")(kill-buffer "bash-errors"))))

    (add-hook 'eshell-mode-hook 'eshell-load-bash-aliases)
----

-- 2022-06-12 [[Edgar Vincent]]:

Drawing upon Arthur Miller's function, I simplified a few things. I don't think there is an single/double quote issue when using Bash's <code>alias</code> builtin command, as it seems to use single quotes exclusively.

  (defun eshell-load-bash-aliases ()
    "Read Bash aliases and add them to the list of eshell aliases."
    ;; Bash needs to be run - temporarily - interactively
    ;; in order to get the list of aliases.
      (with-temp-buffer
        (call-process "bash" nil '(t nil) nil "-ci" "alias")
        (goto-char (point-min))
        (while (re-search-forward "alias \\(.+\\)='\\(.+\\)'$" nil t)
          (eshell/alias (match-string 1) (match-string 2)))))

  ;; We only want Bash aliases to be loaded when Eshell loads its own aliases,
  ;; rather than every time `eshell-mode' is enabled.
  (add-hook 'eshell-alias-load-hook 'eshell-load-bash-aliases)
----

----
CategoryEshell
