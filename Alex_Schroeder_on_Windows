;;; See https://www.emacswiki.org/emacs/Alex_Schroeder

;; Open with this file
(setq initial-buffer-choice "~/NOTES")

;; disable fancy stuff
(dolist (mode '(blink-cursor-mode
		tool-bar-mode
		menu-bar-mode
		scroll-bar-mode))
  (when (fboundp mode)
    (funcall mode -1)))

;; active some other bling
;; (toggle-frame-fullscreen)
(show-paren-mode 1)
(winner-mode 1)
(windmove-default-keybindings)
(column-number-mode 1)

;; Make the initial frame less tall because the font size is so large.
;; With emacs-client, it's the other one.
(setq initial-frame-alist
      '((top . 1) (left . 1) (width . 100) (height . 25))
      default-frame-alist initial-frame-alist)

;; I no longer know how custom themes work. It seems I cannot extend
;; themes in the ways I want them to. So now I'm falling back to using
;; face-spec-set all over the place.
(face-spec-set 'default '((t (:family "Iosevka" :height 120 :background "#ffe" :foreground "#111"))))
(face-spec-set 'fixed-pitch '((t (:family "Iosevka Term"))))
(face-spec-set 'fixed-pitch-serif '((t (:family "Iosevka Term"))))
(face-spec-set 'variable-pitch '((t (:family "Iosevka Etoile"))))

(face-spec-set 'error '((t (:foreground "tomato"))))
(face-spec-set 'region '((t (:background "#eeb"))))
(face-spec-set 'secondary-selection '((t (:background "#ffa"))))
(face-spec-set 'mode-line-inactive '((t (:foreground "grey30"))))
(face-spec-set 'mode-line-highlight '((t (:foreground "dim gray"))))
(face-spec-set 'query-replace '((t (:background "dark gray" :foreground "#ffe"))))

(face-spec-set 'highlight '((t (:foreground "grey30"))))
(face-spec-set 'idle-highlight '((t (:background "light gray"))))

(face-spec-set 'completions-highlight '((t (:background "light gray"))))

(face-spec-set 'dictionary-reference-face '((t (:inherit default))))

(face-spec-set 'dired-directory '((t (:inherit font-lock-string-face))))

(face-spec-set 'eglot-highlight-symbol-face '((t (:background "light gray"))))

(face-spec-set 'eshell-prompt '((t (:foreground "#111"))))

(face-spec-set 'font-lock-builtin-face '((t (:foreground "#111"))))
(face-spec-set 'font-lock-comment-face '((t (:foreground "dim gray"))))
(face-spec-set 'font-lock-comment-delimiter-face '((t (:inherit font-lock-comment-face))))
(face-spec-set 'font-lock-constant-face '((t (:inherit bold :foreground "#111"))))
(face-spec-set 'font-lock-doc-face '((t (:inherit font-lock-comment-face :slant italic))))
(face-spec-set 'font-lock-function-name-face '((t (:foreground "#111"))))
(face-spec-set 'font-lock-keyword-face '((t (:inherit font-lock-constant-face :foreground "#111"))))
(face-spec-set 'font-lock-preprocessor-face '((t (:inherit italic))))
(face-spec-set 'font-lock-reference-face '((t (:inherit default))))
(face-spec-set 'font-lock-string-face '((t (:foreground "steel blue"))))
(face-spec-set 'font-lock-type-face '((t (:inherit underline :foreground "#111"))))
(face-spec-set 'font-lock-variable-name-face '((t (:foreground "#111"))))
(face-spec-set 'font-lock-variable-use-face '((t (:foreground "#111"))))
(face-spec-set 'font-lock-warning-face '((t (:foreground "tomato"))))

(face-spec-set 'hbut-face '((t (:inherit link))))
(face-spec-set 'hbut-flash '((t (:background "light gray"))))
(face-spec-set 'hbut-item-face '((t (:inherit link))))

(face-spec-set 'isearch '((t (:foreground "#111" :background "#cfc"))))
(face-spec-set 'isearch-fail '((t (:foreground "#111" :background "#fdd"))))
(face-spec-set 'isearch-group-1 '((t (:foreground "#111" :background "#bfb"))))
(face-spec-set 'isearch-group-2 '((t (:foreground "#111" :background "#9d9"))))
(face-spec-set 'lazy-highlight '((t (:foreground "#111" :background "#dfd"))))

(face-spec-set 'magit-bisect-bad '((t (:foreground "#111" :bold t))))
(face-spec-set 'magit-bisect-good '((t (:foreground "#111" :bold t))))
(face-spec-set 'magit-bisect-skip '((t (:foreground "#111" :bold t))))
(face-spec-set 'magit-branch-remote '((t (:foreground "#111" :bold t))))
(face-spec-set 'magit-branch-warning '((t (:foreground "tomato"))))
(face-spec-set 'magit-header-line '((t (:foreground "#111"))))
(face-spec-set 'magit-section-heading '((t (:foreground "#111" :bold t))))
(face-spec-set 'magit-section-highlight '((t (:foreground "#111"))))
(face-spec-set 'magit-sequence-head '((t (:foreground "#111"))))
(face-spec-set 'git-gutter:added '((t (:foreground "#111"))))
(face-spec-set 'git-gutter:deleted '((t (:foreground "#111"))))
(face-spec-set 'git-gutter:modified '((t (:foreground "#111"))))
(face-spec-set 'git-gutter:separator '((t (:foreground "#111"))))

(face-spec-set 'markdown-blockquote-face '((t (:foreground "dim gray"))))

(face-spec-set 'markup-replacement-face '((t (:inherit default))))

(face-spec-set 'adoc-meta-face '((t (:font "Iosevka"))))
(face-spec-set 'adoc-replacement-face '((t (:foreground "dim gray"  :font "Iosevka" :bold nil))))
(face-spec-set 'adoc-preprocessor-face '((t (:foreground "dim gray" :bold nil))))
(face-spec-set 'adoc-command-face '((t (:foreground "dim gray" :font "Iosevka" :bold nil :box nil))))
(face-spec-set 'adoc-complex-replacement-face '((t (:font "Iosevka" :foreground "dim gray" :background "#ffe" :bold t :box nil))))
(face-spec-set 'adoc-typewriter-face '((t (:foreground "dim gray" :bold nil))))
(face-spec-set 'adoc-verbatim-face '((t (:background "#ffe"))))
(face-spec-set 'adoc-emphasis-face '((t (:foreground "dim gray" :italic t))))
(face-spec-set 'adoc-bold-face '((t (:foreground "dim gray" :bold t))))
(face-spec-set 'adoc-secondary-text-face '((t (:foreground "#111"))))
(face-spec-set 'adoc-gen-face '((t (:foreground "#111" :bold t))))
(face-spec-set 'adoc-reference-face '((t (:inherit link))))
               
(face-spec-set 'rcirc-my-nick '((t (:foreground "steel blue"))))
(face-spec-set 'rcirc-dim-nick '((t (:foreground "dim gray"))))
(face-spec-set 'rcirc-prompt '((t (:inherit bold))))

(face-spec-set 'sh-quoted-exec '((t (:foreground "tomato"))))

(face-spec-set 'wgrep-delete-face '((t (:inherit font-lock-comment-face :strike-through t))))
(face-spec-set 'wgrep-done-face '((t (:inherit default))))
(face-spec-set 'wgrep-face '((t (:inherit default))))
(face-spec-set 'wgrep-file-face '((t (:inherit default))))

(face-spec-set 'tex-verbatim '((t (:foreground "dim gray"))))

(setq ansi-color-names-vector
      ["black" "red3" "green3" "yellow3" "blue2" "magenta3" "cyan3" "gray90"])

;; Monochrome emoji support

;; (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
;; (setq w32-non-USB-fonts '((emoji Segoe\ UI\ Emoji)))
(set-fontset-font t 'unicode (font-spec :family "Segoe UI Emoji") nil 'prepend) 

;; Color emoji on Windows don't work

;; (use-package emojify
;;   :config
;;   (global-emojify-mode)
;;   (global-emojify-mode-line-mode -1))

;; at the very end, resume where we left off
(setq desktop-restore-frames nil
      desktop-save t
      desktop-load-locked-desktop t
      ;; don't save any files
      desktop-files-not-to-save ""
      desktop-globals-to-save
      '(desktop-missing-file-warning
        search-ring
        regexp-search-ring
        file-name-history
        asc:file-names-seen)
      desktop-modes-not-to-save
      '(tags-table-mode Info-mode
	dired-mode eww-mode))
(desktop-save-mode 1)

;; This is stuff Emacs adds automatically

;; enable disabled stuff
(put 'narrow-to-region 'disabled nil)
(put 'downcase-region 'disabled nil)

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(org-fold-core-style 'overlays)
 '(package-selected-packages
   '(adoc-mode browse-kill-ring emojify expand-region expand-selection
               idle-highlight-mode langtool
               langtool-ignore-fonts langtool-popup magit
               markdown-mode move-text password-generator rw-hunspell
               seq swiper typewriter-roll-mode typo use-package wgrep)))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )

;; Install use-package if necessary. The use-package expressions then
;; contain :ensure t for further installations.
(package-initialize)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

;; No PuTTY
(eval-after-load "tramp" '(tramp-without-putty))

(defun tramp-without-putty ()
  "Disable all putty related stuff."
  ;; PuTTY: no snooping for credentials in the registry (Talk to IT security: Patrick)
  (setq tramp-completion-function-alist-putty nil)
  (defun tramp-parse-putty (&rest ignore) "Never parse PuTTY sessions." nil))

;; UTF-8
(prefer-coding-system 'utf-8)

;; No tabs
(setq-default indent-tabs-mode nil
              css-indent-offset 2)

;; save minibuffer history
(savehist-mode 1)

;; settings
(setq visible-bell t
      completion-ignore-case t
      read-buffer-completion-ignore-case t
      ;; use flex everywhere!
      completion-styles '(basic partial-completion flex)
      completion-category-overrides nil
      completion-category-defaults nil)
(setq sentence-end-double-space nil)

;; on Windows, the menu button of the Atreus keyboard I use is not
;; mapped to M-x
(global-set-key (kbd "<apps>") 'execute-extended-command)

;; buffers
(use-package ibuffer
  :ensure t
  :bind ("C-x C-b" . ibuffer)
  :config (setq ibuffer-formats
                ;; switch formats using `
                '((mark " "
                        (name 40 40 :left :elide)
                        " " filename-and-process)
                  (mark " "
                        (name 20 20 :left :elide)
                        " " filename))))

(global-set-key (kbd "C-x b") 'switch-buffer-or-find-file)

(defvar asc:file-names-seen nil
  "List of file names seen.")

(defun asc:file-names-seen-update ()
  "Add the current file name to `asc:file-names-seen'."
  (let ((name (or buffer-file-name dired-directory)))
    (when name
      (setq asc:file-names-seen
            (cons name (delete name asc:file-names-seen))))))

(add-hook 'find-file-hook 'asc:file-names-seen-update)
(add-hook 'dired-after-readin-hook 'asc:file-names-seen-update)

(defvar switch-buffer-or-find-file-history nil
  "History of file names or buffers picked.")

;; default history-length is 100 which is not enough
(put 'switch-buffer-or-find-file-history 'history-length 1000)

(defun switch-buffer-or-find-file ()
  "Switch buffer or find file."
  (interactive)
  (let ((buffer-names (mapcar 'buffer-name (buffer-list)))
        (file-names nil)
        (file-names-alist nil)
        (default nil)
        (this-buffer-name (buffer-name (current-buffer))))
    ;; build filename list (reversed!)
    (dolist (full-name asc:file-names-seen)
      ;; file-directory-p invokes tramp, which asks for passwords…
      (let* ((name (if (and (or (not (fboundp 'tramp-tramp-file-p))
                                (not (tramp-tramp-file-p full-name)))
                            (file-directory-p full-name))
                       ;; parent directory with a slash…
                       (file-name-as-directory
                        (file-name-nondirectory
                         (directory-file-name full-name)))
                     ;; filename
                     (file-name-nondirectory full-name)))
             (full-names (assoc name file-names-alist)))
        (setq file-names (cons name file-names))
        (if full-names
            (setcdr full-names (cons full-name (cdr full-names)))
          (setq file-names-alist (cons (cons name (list full-name))
                                       file-names-alist)))))
    ;; filter beginning of the buffer name list and figure out the default
    (while (and (not default) buffer-names)
      (let ((name (car buffer-names)))
        (if (or (string= (substring name 0 1) " ")
                (eq this-buffer-name name))
            (setq buffer-names (cdr buffer-names))
          (setq default name))))
    (setq candidates (completion-table-merge buffer-names file-names))
    (let* ((name (completing-read
                  (format "Switch to (%s): " default)
                  candidates
                  (lambda (s)
                    (not (or (string= s "")
                             (string= (substring s 0 1) " ")
                             (eq this-buffer-name s))))
                  nil nil
                  'switch-buffer-or-find-file-history
                  default))
           (buf (get-buffer name))
           (files (cdr (assoc name file-names-alist))))
      (cond (buf (switch-to-buffer buf))
            ((= 0 (length files))
             (message "No such file found, creating new buffer")
             (find-file name))
            ((= 1 (length files))
             (find-file (car files)))
            (t (find-file
                (completing-read "Which one of these files: " files)))))))

;; no casual window splitting
(setq special-display-buffer-names
      '("*compilation*" "*info*" "*Help*" "*grep*")
      special-display-function 'display-buffer-same-window)

;; selection
(use-package expand-region
  :ensure t
  :bind ("C-'" . er/expand-region))

;; German
(setq default-input-method 'german-prefix
      calendar-week-start-day 1)

;; completion
(global-set-key (kbd "C-<tab>") #'hippie-expand)
(setq hippie-expand-try-functions-list
      '(try-expand-all-abbrevs try-expand-dabbrev
	try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill
	try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(define-key minibuffer-local-map (kbd "C-<tab>") #'hippie-expand)

;; move line with M-up and M-down
(use-package move-text
  :ensure t
  :config (move-text-default-bindings))

;; idle highlight
(use-package idle-highlight-mode
  :ensure t
  :config (global-idle-highlight-mode))

(add-hook 'grep-mode-hook (lambda () (idle-highlight-mode 0)))

;; http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html
(defvar endless/fill nil
  "The current state of filling.")

(defun endless/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (cond ((or (not (eq last-command 'endless/fill-or-unfill))
             (eq endless/fill 'sentence))
         (message "Normal fill")
         (setq endless/fill nil)
         (call-interactively #'fill-paragraph))
        ((not endless/fill)
         (message "Unfill")
         (let ((fill-column (point-max)))
           (setq endless/fill 'unfill)
           (call-interactively #'fill-paragraph)))
        ((eq endless/fill 'unfill)
         (message "One line one sentence")
         (setq endless/fill 'sentence)
         (let ((fill-column (point-max)))
           (setq endless/fill 'unfill)
           (call-interactively #'fill-paragraph))
         (beginning-of-line)
         (save-excursion
           (while (re-search-forward "[.!?]['\"]?" (line-end-position) t)
             (newline)
             (while (eq (char-after) ? )
               (delete-char 1)))))))

(global-set-key [remap fill-paragraph]
                #'endless/fill-or-unfill)

;; Dired
(setq dired-recursive-deletes 'always
      dired-recursive-copies 'always
      dired-deletion-confirmer 'y-or-n-p
      dired-clean-up-buffers-too nil
      delete-by-moving-to-trash t
      dired-dwim-target t
      ;; add -v for the natural sort of (version) numbers within text
      dired-listing-switches "-alv")
                              
(setenv "LANG" "de_CH.UTF-8")
(setq ispell-dictionary-alist
      '(("de_CH" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil iso-latin-1)
        ;; add apostrophe
        ("en_US" "[[:alpha:]]" "[^[:alpha:]]" "['0-9]" t ("-d" "en_US") nil ascii))
      ispell-hunspell-dictionary-alist ispell-dictionary-alist
      ;; default to Swiss German
      ispell-local-dictionary "de_CH")

(use-package dictionary
  :bind ("C-c d" . dictionary-search))

;; Swiper
(use-package swiper :ensure t
  :commands (swiper-from-isearch)
  :bind ("C-o" . swiper))

;; Number Mark
(add-to-list 'load-path (expand-file-name "asc" user-emacs-directory))
(autoload 'number-mark-mode "number-mark.el" "Working with numbers." t)

;; Typo Mode
(use-package typo
  :ensure t)

;; AsciiDoc
(use-package adoc-mode
  :ensure t
  :mode "\\.adoc\\'")

(add-hook 'adoc-mode-hook 'asc:adoc-mode-init)

(defun asc:adoc-mode-init ()
  (visual-line-mode)
  (flyspell-mode)
  (abbrev-mode)
  (number-mark-mode)
  (hi-lock-face-buffer "^\\([^.!? \t\r\n]+ +\\)\\{25\\}\\(.+\\)" 'hi-pink 2)
  (hi-lock-face-buffer "\\bwill\\|simple\\|easy\\|just\\b")
  (add-to-list 'adoc-font-lock-keywords
               '("TODO" . 'font-lock-warning-face))
  (setq ispell-local-dictionary "en_US"))

;; fix warning message
(defface adoc-delimiter '((t (:inherit adoc-meta-face))) "No idea")

(defun asc:modules-directory ()
  "Return the modules directory we're in."
  (let ((dir default-directory))
    (while (and
            (not (string= dir "/"))
            (not (string= "modules"
                          (file-name-nondirectory
                           (directory-file-name dir)))))
      (setq dir (expand-file-name
                 (file-name-concat dir ".."))))
    dir))

(defun asc:module-name ()
  "Return the name of the module we're in."
  (let ((dir default-directory)
        last)
    (while (not (string= "modules"
                         (file-name-nondirectory
                          (directory-file-name dir))))
      (setq last (file-name-nondirectory
                  (directory-file-name dir))
            dir (expand-file-name
                 (file-name-concat dir ".."))))
    last))

(defun asc:to-environment-variables ()
  "Turn the current thing into an adoc environment variable link."
  (interactive)
  (skip-chars-backward "a-zA-Z.")
  (when (equal (char-before) ?`)
    (delete-char -1))
  (let ((start (point)))
    (skip-chars-forward "a-zA-Z.")
    (when (equal (char-after) ?`)
      (delete-char 1))
    (let ((s (buffer-substring start (point))))
      (insert "]")
      (goto-char start)
      (insert "xref:")
      (unless (string-match "/configuration/" (buffer-file-name))
        (insert "configuration:"))
      (insert "environment-variables.adoc#"
              (replace-regexp-in-string "\\." "-" (downcase s))
              "["))))

(defun asc:to-setting ()
  "Turn the current thing into an adoc setting link."
  (interactive)
  (skip-chars-backward "a-zA-Z.")
  (when (equal (char-before) ?`)
    (delete-char -1))
  (let ((start (point)))
    (skip-chars-forward "a-zA-Z.")
    (when (equal (char-after) ?`)
      (delete-char 1))
    (let ((s (buffer-substring start (point))))
      (insert "]")
      (goto-char start)
      (insert "xref:")
      (unless (string-match "/configuration/" (buffer-file-name))
        (insert "configuration:"))
      (insert "settings.adoc#"
              (replace-regexp-in-string "\\." "-" (downcase s))
              "["))))

(defun asc:to-parameter ()
  "Turn the current thing into an adoc parameter link."
  (interactive)
  (skip-chars-backward "a-zA-Z0-9_")
  (when (equal (char-before) ?`)
    (delete-char -1))
  (let ((start (point)))
    (skip-chars-forward "a-zA-Z0-9_")
    (when (equal (char-after) ?`)
      (delete-char 1))
    (let ((s (buffer-substring start (point))))
      (insert "]")
      (goto-char start)
      (insert "xref:")
      (unless (string-match "/configuration/" (buffer-file-name))
        (insert "configuration:"))
      (insert "parameter.adoc#"
              (replace-regexp-in-string "\\." "-" (downcase s))
              "["))))

(autoload 'adoc-xref-id-at-point "adoc-mode")

(defun adoc-example-at-point ()
  "Return the example at point."
  (save-excursion
    (goto-char (line-beginning-position))
    (when (looking-at "include::example\\$\\([^[]+\\)")
      (list (append '("examples") (split-string (match-string 1) ":"))))))

(defun adoc-image-at-point ()
  "Return the image at point."
  (save-excursion
    (goto-char (line-beginning-position))
    (when (looking-at "image::\\([^[]+\\)")
      (list (append '("images") (split-string (match-string 1) ":"))))))

(defun adoc-page-at-point ()
  "Return the page at point."
  (save-excursion
    (let* ((id (adoc-xref-id-at-point))
           (elems (when id (split-string (adoc-xref-id-at-point) "#")))
           (path (car elems))
           (frag (nth 1 elems)))
      (cond ((and path (string-match "\\.adoc$" path))
             (list (append '("pages") (split-string path ":")) frag))
            ((= (length elems) 1)
             (cons nil elems))))))

(defun adoc-include-at-point ()
  "Return the file at point."
  (save-excursion
    (goto-char (line-beginning-position))
    (when (looking-at "include::\\([^[]+\\)")
      (let ((elems (split-string (match-string 1) ":")))
        (when (string-match "^partial\\$" (car (last elems)))
          (setcar (last elems) (substring (car (last elems)) 8)))
        (list (append '("partials") elems))))))

(defun adoc-attribute-use-at-point ()
  "Return the attribute used at point."
  (save-excursion
    (let ((from (when (or (eq (char-before) ?\{)
                          (and (skip-chars-backward "a-z_")
                               (eq (char-before) ?\{)))
                  (point)))
          (to (and (skip-chars-forward "a-z_")
                   (eq (char-after) ?\})
                   (point))))
      (when (and from to)
        (let ((attribute (buffer-substring from to)))
          (list (list "partials" "ROOT" "attributes.adoc") attribute))))))

(defun adoc-cross-reference-at-point ()
  "Return the id used at point.
<<foo,bar>> is detected by `adoc-xref-id-at-point' and therefore
handled by `adoc-page-at-point', but <<foo>> is not, strangely."
  (save-excursion
    (let ((from (when (search-backward "<<" (line-beginning-position) t)
                  (+ (point) 2)))
          (to (when (search-forward ">>" (line-end-position) t)
                  (- (point) 2))))
      (when (and from to)
        (list nil (car (split-string (buffer-substring from to) ",")))))))

(keymap-global-set "M-<return>" 'asc:follow-link)

(autoload 'ffap-guesser "ffap")

(defun asc:follow-link ()
  "Follow the link of whatever we're looking at."
  (interactive)
  (let (thing)
    (cond ((setq thing (ffap-guesser))
           (find-file thing))
          ((adoc-xref))
          ((and (setq thing (sexp-at-point))
                (or (boundp thing)
                    (listp thing)))
           (message "%S" (eval thing)))
          ((condition-case err (xref-find-definitions
                                (xref-backend-identifier-at-point
                                 (xref-find-backend)))
             (t nil)))
          ((setq thing (ivy-thing-at-point))
           (swiper-all thing))
          (t (message "?")))))

(defun adoc-xref ()
  "Follow adoc references and open the associated file."
  (let* ((data (or (adoc-example-at-point)
                   (adoc-image-at-point)
                   (adoc-page-at-point)
                   (adoc-cross-reference-at-point)
                   (adoc-include-at-point)
                   (adoc-attribute-use-at-point)))
         (path (car data))
         (id (nth 1 data))
         (modules-dir (asc:modules-directory))
         module dir file target found)
    (when (and path (not (string= modules-dir "/")))
      (cond ((= 3 (length path)) (setq module (nth 1 path) dir (nth 0 path) file (nth 2 path)))
            ((= 2 (length path)) (setq module (asc:module-name) dir (nth 0 path) file (nth 1 path)))
            (t (error "Too long: %S" path)))
      (setq found t
            target (file-name-concat modules-dir module dir file))
      (find-file target))
    (when id
      (let ((re (concat "#" id
                        "\\|\\[\\[" id "\\]\\]"
                        "\\|= *" (replace-regexp-in-string "-" " " id) "$")))
        (goto-char (point-min))
        (search-forward-regexp re)
        (setq found t)))
    found))

;; (defun adoc-ref ()
;;   "Follow adoc references and jump to the correct definition."
;;   (let ((id (adoc-cross-reference-at-point)))
;;     (when id
;;       (let ((re (concat "#" id
;;                         "\\|\\[\\[" id "\\]\\]"
;;                         "\\|= *" (replace-regexp-in-string "-" " " id) "$")))
;;         (goto-char (point-min))
;;         (search-forward-regexp re)))))

;; See (edit-abbrevs)

(define-skeleton adoc:good-example "{goodexample}" nil
  "====\n"
  "{goodexample} " _ "\n"
  "====")

(define-skeleton adoc:bad-example "{badexample}" nil
  "====\n"
  "{badexample} " _ "\n"
  "====")

(define-skeleton adoc:ok-example "{okexample}" nil
  "====\n"
  "{okexample} " _ "\n"
  "====")

(define-skeleton adoc:code-example "code example" nil
  "." _ "\n"
  "[source#,]\n"
  "----\n"
  "\n"
  "----")

(define-skeleton adoc:table "tab" nil
  "[cols=\"1,1\"]\n"
  "|===\n"
  "|" _ " | header\n"
  "\n"
  "|cell\n"
  "|cell\n"
  "|===\n")

(defun adoc:nav-entry ()
  "Insert navigation entry and open file."
  (interactive)
  (unless (string= (file-name-nondirectory (buffer-file-name)) "nav.adoc")
    (error "Only works in nav.adoc files"))
  (let ((filename (string-replace " " "-"
                   (string-replace ".adoc" ""
                    (read-string "New file name: ")))))
    (dotimes (n (read-number "Level: " 3))
      (insert "*"))
    (insert " xref:" filename ".adoc[]")
    (find-file-other-window (concat "pages/" filename ".adoc"))
    (insert "= " (string-replace "-" " "
                                 (concat (capitalize (substring filename 0 1))
                                         (substring filename 1)))
            "\n"
            "include::ROOT:partial$attributes.adoc[]\n"
            "{help_url}/BSI%20CRM/Wertelisten/H_Wertelisten.htm[{help},role=mod]\n"
            "{spec_url}/Wertelisten/CTL_Wertelisten.htm[{spec},role=mod]\n")))

(defun adoc:image ()
  "Insert image with caption."
  (interactive)
  (let ((caption (read-string "Caption: "))
        (slug (read-string "Slug: "))
        (filename (file-name-nondirectory
                   (read-file-name "Image: " "../images/" nil t))))
    (insert "." caption "\n"
            "[#" slug "]\n"
            "image::" filename "[]\n")))

(defun adoc:xref ()
  "Insert xref to existing file."
  (interactive)
  (let* ((filename (read-file-name "File: " nil nil t))
         (path-elements (split-string filename "/"))
         (module (nth (- (length path-elements) 3) path-elements))
         (file (file-name-nondirectory filename))
         (this-path-elements (split-string default-directory "/"))
         (this-module (nth (- (length this-path-elements) 3) this-path-elements)))
    (if (string= module this-module)
        (insert "xref:" file "[]")
      (insert "xref:" module ":" file "[]"))))

(defun adoc:example ()
  "Insert example with existing file."
  (interactive)
  (let ((caption (read-string "Caption: "))
        (slug (read-string "Slug: "))
        (prefix (expand-file-name "../examples/"))
        (filename (read-file-name "Example: " "../examples/" nil t)))
    (setq filename (substring filename (length prefix))) ; doesn't work for examples from elsewhere!
    (insert "." caption "\n"
            "[source#" slug ",java]\n"
            "----\n"
            "include::example$" filename "[tags=]\n"
            "----\n"
            "<1>")))

(defun asc:adoc-callout-shift (shift)
  "Shift the remaining callouts by SHIFT."
  (interactive "p")
  (let ((shift (or shift 1))
        first n)
    (catch 'done
      (save-excursion
        (while (re-search-forward "<\\([0-9]+\\)>" nil t)
          (setq n (string-to-number (match-string 1)))
          (if (not first)
              (setq first n)
            (setq first (1+ first))
            (unless (= first n)
              (throw 'done first)))
          (replace-match (format "<%d>" (+ n shift))) )))))

(defconst asc:java-style
  '((c-basic-offset . 2)
    (c-comment-only-line-offset 0 . 0)
    (c-offsets-alist
     (inline-open . 0)
     (topmost-intro-cont . +)
     (statement-block-intro . +)
     (knr-argdecl-intro . 5)
     (substatement-open . +)
     (substatement-label . +)
     (label . +)
     (statement-case-open . +)
     (statement-cont . +)
     (arglist-intro . c-lineup-arglist-intro-after-paren)
     (arglist-close . c-lineup-arglist)
     (brace-list-intro first c-lineup-2nd-brace-entry-in-arglist c-lineup-class-decl-init-+ +)
     (access-label . 0)
     (inher-cont . c-lineup-java-inher)
     (func-decl-cont . c-lineup-java-throws)))
  "My C Programming Style")
(c-add-style "java" asc:java-style)

;; JavaScript
(setq js-indent-level 2)

;; Customizations for all modes in CC Mode.
(defun asc:java-mode-common-hook ()
  (setq tab-width 8
        indent-tabs-mode nil))
(add-hook 'java-mode-hook 'asc:java-mode-common-hook)

;; https://www.languagetool.org/download/snapshots/?C=M;O=D
(setq langtool-language-tool-jar "/home/alex/dev/LanguageTool-6.8-SNAPSHOT/languagetool-commandline.jar"
      langtool-default-language "en-US"
      langtool-java-user-arguments '("-Dfile.encoding=UTF-8"))

(use-package langtool
  :ensure t
  :bind (("\C-x4w" . langtool-check)
         ("\C-x4W" . langtool-check-done)
         ("\C-x4l" . langtool-switch-default-language)
         ("\C-x44" . langtool-show-message-at-point)
         ("\C-x4c" . langtool-interactive-correction)))
(use-package langtool-popup
  :ensure t)
(use-package langtool-ignore-fonts
  :ensure t)
(langtool-ignore-fonts-add
 'adoc-mode '(markup-anchor-face
              markup-attribute-face
              ;; markup-big-face
              ;; markup-bold-face
              markup-code-face
              markup-command-face
              ;; markup-comment-face
              markup-complex-replacement-face
              ;; markup-emphasis-face
              markup-error-face
              markup-gen-face
              markup-internal-reference-face
              ;; markup-italic-face
              ;; markup-list-face
              markup-meta-face
              markup-meta-hide-face
              markup-passthrough-face
              markup-preprocessor-face
              markup-reference-face
              markup-replacement-face
              ;; markup-secondary-text-face
              ;; markup-small-face
              ;; markup-strong-face
              ;; markup-subscript-face
              ;; markup-superscript-face
              ;; markup-table-cell-face
              ;; markup-table-face
              ;; markup-table-row-face
              ;; markup-title-0-face
              ;; markup-title-1-face
              ;; markup-title-2-face
              ;; markup-title-3-face
              ;; markup-title-4-face
              ;; markup-title-5-face
              ;; markup-typewriter-face
              ;; markup-underline-face
              ;; markup-value-face
              markup-verbatim-face))

;; ediff
(setq ediff-window-setup-function 'ediff-setup-windows-plain)

;; magit
(use-package magit
  :ensure t
  :bind ("C-c g" . magit-status))

;; (use-package git-gutter
;;   :ensure t)

;; grep

(defun grep-word-at-point (word)
  "Grep for the region, or thing at point.
Per default, the same extension is used as the file-name of the
current buffer. Use a prefix argument to override either."
  (interactive (list (thing-at-point 'symbol)))
  (when (use-region-p)
    (setq word (buffer-substring-no-properties
		(region-beginning) (region-end))))
  (let* ((file-name (buffer-file-name))
	 (extension (and file-name (file-name-extension file-name)))
	 (pattern (if extension (concat "*." extension) "*")))
    (when current-prefix-arg
      (setq word (read-string "Grep for: " word)
	    pattern (read-string "Files to grep: " pattern)))
    (setq word (replace-regexp-in-string "\"" "\\\"" word))
    (grep (format "grep --color -niH --null -e \"%s\" %s" word pattern))))

(global-set-key (kbd "C-c s") 'grep-word-at-point)

(defun git-grep-word-at-point (word)
  "Git grep for the region, or thing at point."
  (interactive (list (thing-at-point 'symbol)))
  (when (use-region-p)
    (setq word (buffer-substring-no-properties
		(region-beginning) (region-end))))
  (when (or current-prefix-arg
            (null word))
    (setq word (read-string "Git grep for: " word)))
  (git-grep (regexp-quote word)))

(defun git-grep (regexp)
  "Git grep for the REGEXP."
  (interactive "sRegexp: ")
  (grep (format "git grep --color -niH -e \"%s\"" regexp)))

(use-package wgrep
  :ensure t)

;; kill-ring

(use-package browse-kill-ring
  :ensure t
  :config (browse-kill-ring-default-keybindings))

;; WSL clipboard fix
(setq interprogram-cut-function 
      (lambda (text)
        (with-temp-buffer
          (insert text)
          (call-process-region (point-min) (point-max) "win32yank.exe" nil 0 nil "-i" "--crlf"))))

;; eshell

(global-set-key (kbd "C-z") 'asc:eshell-here)

(defun asc:eshell-here (&optional arg)
  (interactive "P")
  (if (and arg (buffer-file-name))
      (let ((dir (file-name-directory (buffer-file-name))))
	(eshell)
	(cd dir))
    (eshell arg)))

(global-set-key (kbd "C-x 4 C-z") 'asc:eshell-other-window)

(defun asc:eshell-other-window (&optional arg)
  (interactive "P")
  (if (one-window-p)
      (split-window)
    (other-window 1))
  (eshell arg))

(setq eshell-history-size 500
      eshell-save-history-on-exit t
      eshell-hist-ignoredups t
      eshell-last-dir-ring-size 500)

(add-hook 'eshell-mode-hook #'asc:eshell-init)

(defun asc:eshell-init ()
  (local-set-key (kbd "C-z") 'bury-buffer)
  (local-set-key (kbd "C-a") 'eshell-bol)
  (local-set-key (kbd "C-w") 'asc:kill-region)
  (local-set-key (kbd "<up>") 'previous-line)
  (local-set-key (kbd "<down>") 'next-line)
  (eldoc-mode 1)
  (setenv "PAGER" "cat")
  (setenv "EDITOR" "emacsclient"))

(defun asc:kill-region (begin end)
  "Since `eshell' adds read-only prompts, I need to override this."
  (interactive "r")
  (let ((inhibit-read-only t))
    (kill-region (region-beginning) (region-end))))

;; add isearch

(require 'transient)
(transient-define-prefix cc/isearch-menu ()
  "isearch Menu"
  [["Edit Search String"
    ("e"
     "Edit the search string (recursive)"
     isearch-edit-string
     :transient nil)
    ("w"
     "Pull next word or character word from buffer"
     isearch-yank-word-or-char
     :transient nil)
    ("s"
     "Pull next symbol or character from buffer"
     isearch-yank-symbol-or-char
     :transient nil)
    ("l"
     "Pull rest of line from buffer"
     isearch-yank-line
     :transient nil)
    ("y"
     "Pull string from kill ring"
     isearch-yank-kill
     :transient nil)
    ("t"
     "Pull thing from buffer"
     isearch-forward-thing-at-point
     :transient nil)]

   ["Replace"
    ("q"
     "Start ‘query-replace’"
     isearch-query-replace
     :if-nil buffer-read-only
     :transient nil)
    ("x"
     "Start ‘query-replace-regexp’"
     isearch-query-replace-regexp
     :if-nil buffer-read-only     
     :transient nil)]]

  [["Toggle"
    ("X"
     "Toggle regexp searching"
     isearch-toggle-regexp
     :transient nil)
    ("S"
     "Toggle symbol searching"
     isearch-toggle-symbol
     :transient nil)
    ("W"
     "Toggle word searching"
     isearch-toggle-word
     :transient nil)
    ("F"
     "Toggle case fold"
     isearch-toggle-case-fold
     :transient nil)
    ("L"
     "Toggle lax whitespace"
     isearch-toggle-lax-whitespace
     :transient nil)]

   ["Misc"
    ("o"
     "occur"
     isearch-occur
     :transient nil)]])

(define-key isearch-mode-map (kbd "<f2>") 'cc/isearch-menu)
(define-key isearch-mode-map (kbd "C-o") 'swiper-from-isearch)

(global-set-key (kbd "C-x 8 1 2") "½")
(global-set-key (kbd "C-x 8 _ 2") "₂")
(global-set-key (kbd "C-x 8 <right>") "→")
