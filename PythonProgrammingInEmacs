[[ja:PythonProgrammingInEmacs-ja]]
[[ja:PythonProgrammingInEmacs-ja]]
This page collects information for creating a usable Python programming environment in Emacs.
==Quick start==
The quickest way to start is just to open a Python file in Emacs -- `python-mode' has a nice feature-set as is -- see below for details.

Beyond that, as people ask for recommendations fairly often, the following is a reasonable approach:
* If you already use one of the StarterKits like [[Spacemacs]] or DoomEmacs, then use its Python configuration.
* If you want to set up a relatively complete environment quickly, and have someone else choose individual packages and handle combining them, then use one of the IDE packages listed below.  Elpy appears to be the most popular Python-specific IDE package, while LspMode supports many languages and has gained a lot of developer attention.
* If you want complete control then select the packages you want from the Support Features section.  

==Python mode==
The built-in `python-mode' supports, from its help, "Syntax highlighting, Indentation, Movement, Shell interaction, Shell completion, Shell virtualenv support, Shell package support, Shell syntax highlighting, Pdb tracking, Symbol completion, Skeletons, FFAP, Code Check, ElDoc, Imenu.

Some history: the built-in `python-mode' comes from the [ProgrammingWithPythonDotElGallina 'gallina' python.el], which comes with Emacs 24.2 and up; this is different from the modes from [ProgrammingWithPythonDotEl 'loveshack' python.el] , which was the built-in mode up to Emacs 24.1, and [ProgrammingWithPythonModeDotEl python-mode.el], listed below under IDE packages.

== IDE packages==
These provide powerful and relatively complete environments by combining and customizing other packages, both Emacs Lisp and Python, and resolving conflicts between them. 
===Spacemacs===
* [https://develop.spacemacs.org/layers/+lang/python/README.html Python layer] for [[Spacemacs]].  Builds on anaconda-mode and several other packages.
===Doom===
* [https://github.com/hlissner/doom-emacs/blob/91ced7997537cc692e2a06294a428c5b4037d687/modules/lang/python/README.org Python module] for DoomEmacs.  
===Elpy===
* [https://github.com/jorgenschaefer/elpy Elpy].  The installation instructions are [https://elpy.readthedocs.io/en/latest/introduction.html#installation here].
===Language Server Protocol===
Any of the main [LanguageServerProtocol] packages should support Python programming with a variety of backends.  [LspMode] provides these guides to configuring backends
* [https://emacs-lsp.github.io/lsp-mode/page/lsp-jedi/ Jedi language server]
* [https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/ Palantir's python-language-server], also based on Jedi
* [https://emacs-lsp.github.io/lsp-python-ms/ Microsoft's python-language-server]
* [https://emacs-lsp.github.io/lsp-pyright/ Microsoft's Pyright language server].  See [https://gitlab.com/nathanfurnal/dotemacs/-/snippets/2060535 here] for a gist of a full-featured Python config using [https://github.com/emacs-lsp/lsp-mode lsp-mode], `lsp-ui', `lsp-pyright', `pyvenv', `treemacs' and `dap-mode'.
* [https://emacs-lsp.github.io/lsp-mode/page/lsp-pylsp/ Python LSP Server]
===python-mode.el===
* [ProgrammingWithPythonModeDotEl python-mode.el].  Replaces the `python-mode' in python.el.
===Anaconda mode===
* [https://github.com/proofit404/anaconda-mode anaconda-mode] 
===eglot===
* [https://github.com/joaotavora/eglot eglot] (natively supported since Emacs 29)
== Support Features ==
Various features that can be added to or improved in Emacs.  Note that the IDE packages listed above provide many of these using packages referred to below.

===Virtual environments==
There is some built-in support for virtual environments in python.el, but these packages provide more features.
* [https://github.com/jorgenschaefer/pyvenv pyvenv] - used in elpy, written by the same author. [https://github.com/marcwebbie/auto-virtualenv auto-virtualenv] provides automatic activation.
* [https://github.com/proofit404/pyenv-mode pyenv-mode] - uses [https://github.com/yyuu/pyenv pyenv], including automatic activation via [[Projectile]].
* [https://github.com/porterjamesj/virtualenvwrapper.el virtualenvwrapper].  [https://github.com/robert-zaremba/auto-virtualenvwrapper.el auto-virtualenvwrapper] provides automatic activation.
* [https://github.com/necaris/conda.el conda.el] - for working with conda environments, including automatic activation.  

* [https://github.com/pwalsh/pipenv.el pipenv.el] - A [https://docs.pipenv.org/ Pipenv] porcelain inside Emacs, including automatic activation through [[Projectile]]. 
* [https://github.com/mukuge/npy.el npy.el] - for a nicer integration of Pipenv virtualenvs and inferior python processes.

===Indentation===
The defaults should see you compliant with PEP8 but see IndentingPython for detail.

=== Comment/Uncomment Region ===
If you have `transient-mark-mode' on, you can just use `comment-dwim': select a region and hit `M-;'. The DoWhatIMean means that it will comment or uncomment the region as appropriate. If you do not have `transient-mark-mode' on by default, you can hit C-SPC twice to activate it temporarily.

[ProgrammingWithPythonModeDotEl python-mode.el] also provides `py-comment-region and commands to comment/uncomment all known forms, def, block, clause etc.

===Completion===

Note that some IDE packages provide completion, e.g. Elpy provides completion using either jedi or rope as a backend to CompanyMode, and anaconda-mode provides completion via CompanyMode or AutoComplete.

You can also configure completion by using either jedi or rope as a backend to either CompanyMode or AutoComplete.

For [https://github.com/davidhalter/jedi jedi]:
* [https://melpa.org/#/company-jedi company-jedi] provides a backend for CompanyMode.
* [https://github.com/tkf/emacs-jedi Jedi.el] provides a backend for AutoComplete.

For [https://pypi.python.org/pypi/rope rope]:
* [https://github.com/python-rope/ropemacs Ropemacs] can be used as a backend for both CompanyMode and AutoComplete.

An experiment:
* [https://github.com/tavisrudd/emacs.d/blob/master/dss-completion.el AutoComplete support in IPython shell buffers]

===Code navigation===

The built-in [https://www.emacswiki.org/emacs/ProgrammingWithPythonDotEl python.el] has support for [https://www.emacswiki.org/emacs/ImenuMode imenu] code navigation. By default it uses a tree structure for navigation which presents only top level definitions that can then be 'drilled in to'. If you prefer a flat menu then you can add the following snippet (retrieved from [https://github.com/fgallina/python.el/issues/135#issuecomment-18459589 GitHub]) to your [https://www.emacswiki.org/emacs/InitFile init file]:

{{{
(defun python-imenu-use-flat-index
    ()
  (setq imenu-create-index-function
        #'python-imenu-create-flat-index))

(add-hook 'python-mode-hook
          #'python-imenu-use-flat-index)
}}}

The tools built on jedi support using it to find definitions. [https://github.com/tkf/emacs-jedi-direx jedi-direx] provides a tree-style source code viewer for Python buffers but is not on MELPA.

[[Helm]] provides an interface for navigating buffers via `helm-semantic-or-imenu'. 

[https://melpa.org/#/helm-cscope helm-cscope] provides a Helm interface to [https://melpa.org/#/xcscope xcscope].  [https://pypi.python.org/pypi/pycscope/ pycscope] supports generating the required cscope index of Python source trees.

=== Code generation helpers ===
====python-mode skeletons====
The built-in python-mode comes with several skeletons and key bindings for functions to insert them (`python-skeleton-<foo>').  They can be inserted automatically if you have `abbrev-mode' activated and `python-skeleton-autoinsert' set to `t'.
====yasnippet====
[[Yasnippet]] comes with a broad set of templates for Python.
====sphinx-doc====
[https://melpa.org/#/sphinx-doc sphinx-doc] supports inserting and updating docstring skeletons
as used by [http://www.sphinx-doc.org Sphinx].  
====python-docstring====
[https://melpa.org/#/python-docstring python-docstring] is a minor mode for intelligently
reformatting (refilling) and highlighting Python docstrings. It understands both epytext and Sphinx formats (even intermingled!), so it knows how to reflow them correctly. It will also highlight markup in your docstrings, including epytext and reStructuredText.
====org-recipes====
[https://github.com/tuhdo/org-recipes org-recipes] A code snippet manager with Org and Helm. It is not specific to python and does not expand snippets like yasnippet does, but has the added benefit of combining text with org-mode source blocks that can then be inserted in a buffer via Helm.

===Lint, style and syntax checkers===
Both [[Flycheck]] and [[FlyMake]] can be used to wrap checkers such as pep8, pyflakes (flake8 includes both), pylint and pychecker.  Both support multiple checkers per buffer.
====Flycheck====
[[Flycheck]] comes with [https://www.flycheck.org/en/latest/languages.html#python built-in Python support] for flake8, pylint, Pyright, mypy and the Python compiler.  Checkers are also available for [https://melpa.org/#/flycheck-cython Cython], [https://melpa.org/#/flycheck-pyre Pyre], and LspMode, which includes its own checker.
==== Flymake====
[[FlyMake]] uses pyflakes out of the box - just enable Flymake.

You can also configure Flymake to use flake8 or pylint.

===Refactoring===
[https://github.com/python-rope/ropemacs Ropemacs] is a library using [[Pymacs]] to talk with the Rope refactoring library.

[https://github.com/python-rope/pylsp-rope pylsp-rope] is a plugin to extend the refactoring capabilities of Python LSP Server (pylsp) using the Rope refactoring library.

[https://github.com/abingham/emacs-traad emacs-traad] also supports refactoring using Rope.

[https://github.com/tkf/emacs-jedi Jedi.el] also has some refactoring support.

===Reformatting and PEP8 conformance===
====yapf====
[https://github.com/google/yapf Yapf] attempts to format Python code to the best formatting that conforms to a style guide, even if the original code didn't violate the style guide.  The style guide can be customized; predefined ones include pep8 and google.

Both [https://melpa.org/#/py-yapf py-yapf] and [https://github.com/jorgenschaefer/elpy Elpy] support applying yapf to the current buffer.

====autopep8====
[https://pypi.python.org/pypi/autopep8/ autopep8] formats Python code to conform to the PEP 8 style guide using [https://pypi.python.org/pypi/pep8 the pep8 tool].

Both [https://melpa.org/#/py-autopep8 py-autopep8] and [https://github.com/jorgenschaefer/elpy Elpy] support applying autopep8 to the current buffer.

====black====
[https://github.com/psf/black black] formats Python code to an almost-fixed style, hence "the uncompromising Python code formatter".

Both [https://melpa.org/#/python-black python-black] and [https://github.com/jorgenschaefer/elpy Elpy] support applying black to the current buffer. 

====Tidying imports====
[http://melpa.org/#/py-isort py-isort] using [https://pypi.python.org/pypi/isort isort].

Elpy supports using [https://pypi.python.org/pypi/importmagic importmagic].

[https://github.com/anachronic/importmagic.el importmagic.el] automatically insert missing imports using [https://pypi.python.org/pypi/importmagic importmagic].

===Running tests===
The [http://pytest.org pytest Python package] subsumes several other test packages, as it supports tests written with pytest, nose, unittest and doctest style test suites, including Django and trial.

[https://melpa.org/#/python-pytest python-pytest] supports running pytest with a UI based on [https://melpa.org/#/transient transient], also used by [[Magit]].

[https://melpa.org/#/pytest pytest] also supports running pytest.

Elpy supports the standard unittest discovery runner, the Django discovery runner, nose and pytest

===Reporting test coverage===
[https://melpa.org/#/pycoverage pycoverage] generates reports using  [https://pypi.python.org/pypi/coverage coverage] and provides a minor mode for displaying coverage by overriding `linum-mode'.  Alternatively, a [[Flycheck]] checker could be used to display coverage as below.
{{{
  (flycheck-define-checker python-pycoverage
    "A Python test coverage checker using the pycoverage tool.

See `https://github.com/mattharrison/pycoverage.el'.

This works after pytest has run by marking lines missing
coverage (as reported by pytest) as flycheck issues.  If the code
was updated after pytest was run then nothing is reported.
"
    :command
    ("python" "-c"
     (eval
      (mapconcat 'identity
                 (list
                  "import sys"
                  (format "sys.path.insert(0, '%scov2emacs')" (file-name-directory (locate-library "pycoverage")))
                  "from cov2emacslib.__init__ import main"
                  "main(sys.argv[1:])")
                 ";"))
     "--compile-mode" "--python-file" source-original)
    :error-patterns ((warning line-start (file-name) ":" line ":" (message) line-end))
    :modes (python-mode)))
}}}

===Debugging===

====gud====
The native `python-mode' supports pdb tracking via the GrandUnifiedDebugger: when you execute a block of code that contains some call to Python's pdb (or ipdb) it will prompt the block of code and will follow 
the execution of pdb, marking the current line with an arrow.  

To debug a script run the Emacs command "M-x pdb" and invoke Python's pdb as 
"python -m pdb foo.py"

====realgud====
[https://melpa.org/#/realgud realgud] provides support for pdb, ipdb and trepanning debuggers.  [https://github.com/rocky/emacs-dbgr/wiki/Features Its features not in the gud] include single-keystroke debugger commands inside the source code.

====dap-mode====
[https://melpa.org/#/dap-mode dap-mode] supports debugging using implementations of the [https://microsoft.github.io/debug-adapter-protocol/ Debug Adapter Protocol], and will be configured automatically by LspMode when available.  See the [https://emacs-lsp.github.io/dap-mode/ main docs] and [https://emacs-lsp.github.io/dap-mode/page/configuration/ configuration guide]. 

===Profiling===
Viewing the results from [https://docs.python.org/3/library/profile.html the Python profilers]:
* [https://github.com/GioBo/py-prof py-prof] provides an interactive table for viewing cProfile output in Emacs
* The Python [https://docs.python.org/3/library/profile.html#module-pstats pstats] module provides an interactive tool when a script from a regular shell in Emacs; it can also be used in a Python shell running in Emacs.

=== Interactive environments - Shells, REPLs and notebooks ===
====The Python shell====
You can open an interactive Python shell with `run-python' ("C-c C-p"), and send code for execution by the shell process using the `python-shell-send-*' functions. Please note that on MacOS the natively shipped Python version comes without proper readline support. You might want to install other versions and use them as default for the `run-python` command.

The support includes completion, syntax highlighting, virtualenvs, enabling a package (so relative imports work), and remote execution (for files opened with TrampMode).  Completion is provided through `completion-at-point' and thus works with CompanyMode as well.

Native completion is disabled on Windows per the comment at the definition of `python-shell-completion-native-disabled-interpreters' but non-native completion should still work -- you can test this by eval'ing `(completion-at-point)' in the inferior shell buffer.
====Using IPython as the Python shell==
In Emacs's native python-mode, use:
{{{
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt --InteractiveShell.display_page=True")
}}}
This should work with any recent IPython, including on Windows, and works around an issue when IPython complains about incomplete shell when calling help (e.g. for help(func)). 
* <code>--simple-prompt</code> is needed since IPython 5.
* <code>--InteractiveShell.display_page=True</code> ensures that anything passed to the pager will be displayed as regular output instead

To get help/pydoc to work fully, run the following, e.g. create an IPython profile then put the code into nopager10.py in ~/.ipython/profile_default/startup/
<pre>
import pydoc
import sys
pydoc.help = pydoc.Helper(output = sys.stdout)
</pre>

[https://github.com/jackkamm/ipython-shell-send-el ipython-send-shell] provides replacements for the built-in `python-send-*' commands that support IPython magic commands.

As noted above with the Python shell, native completion is disabled on Windows.
====Emacs IPython Notebook (EIN)====
[https://github.com/millejoh/emacs-ipython-notebook Emacs IPython Notebook (EIN)] provides an IPython Notebook client and integrated REPL (like SLIME) in Emacs. It is available on MELPA as 'ein'.  This replaces [https://github.com/tkf/emacs-ipython-notebook tkf's EIN], which it was [https://github.com/tkf/emacs-ipython-notebook/issues/156 forked from] to keep up with IPython/Jupyter development. 
==== ob-python====
[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-python.html ob-python] provides Org-Babel support for evaluating Python source code.  Python source code blocks in Org Mode can be used to define functions, filter and analyze data, create graphics and figures, and produce reproducible research papers using a style similar to literate programming. It is included in the 'org-plus-contrib' package from [http://orgmode.org/elpa.html the Org Mode ELPA] or [[MELPA]].
====ob-ipython====
[https://github.com/gregsexton/ob-ipython ob-ipython] provides Org-Babel support for evaluating Python source code using an IPython kernel.  It provides similar features to ob-python (and tries to be more robust) as well as IPython-specific features like magics.
====emacs-jupyter====
[https://github.com/nnicandro/emacs-jupyter emacs-jupyter] provides REPL and Org-Babel support for evaluating Python source code using a Jupyter kernel.   It also includes an API for implementing Jupyter kernel frontends in just a few cl-defmethod definitions.
====LaTeX or MarkDown====
[https://github.com/burakbayramli/emacs-ipython emacs-ipython], an Emacs extension that allows execution of python code inside a LaTeX or MarkDown buffer and display its results, text or graphic in the section below. The extension uses Pymacs to connect to an ipython kernel to execute code. 
====Live coding====
[https://github.com/donkirkby/live-py-plugin live-py-mode] is a Python minor mode supporting live coding, inspired by Bret Victor's [https://vimeo.com/36579366 "Inventing on Principle"] .

====Cell-based operation in Python buffers====
These packages support navigating and executing code based on MATLAB-like cells in regular Python buffers.

[https://gitlab.com/wavexx/python-x.el python-x] extends python-mode with features inspired by EmacsSpeaksStatistics and targeted to interactive code evaluation with an inferior Python process.  

[https://github.com/thisch/python-cell.el python-cell]

===Viewing generated documentation===
This refers to documentation generated by [https://docs.python.org/2/library/pydoc.html pydoc] and similar tools.

Emacs' native python-mode supports ElDoc via `python-eldoc-at-point'. This returns documentation for object at point by using the inferior python subprocess to inspect its documentation.

[https://melpa.org/#/pydoc pydoc] supports generating and viewing pydoc documentation either in an Emacs help buffer, with enhancements like linking to code and coloring for readability, or in a web browser.

[https://melpa.org/#/helm-pydoc helm-pydoc] provides a helm interface to pydoc.

Elpy supports viewing documentation from jedi/rope, falling back to pydoc.

===Viewing the official Python documentation===
This refers to the documentation at https://www.python.org/doc/, including the Python language reference, documentation for the Python standard library, the Python tutorial, etc.
====Using Info====
You will first need to install an Info file for the Python documentation.  As of Python 3.8.0, these can be downloaded pre-built from https://docs.python.org/3/archives/ and https://www.python.org/ftp/python/doc, and installed per [https://www.gnu.org/software/emacs/manual/html_node/efaq/Installing-Texinfo-documentation.html Installing Texinfo documentation].

[https://github.com/visigoth/pydoc-info pydoc-info] configures Info to use the Python docs, and provides customized support for Python. The version at Lisp:pydoc-info.el has a tiny update to use the official python.info files mentioned above. 

For more basic configuration, so that `info-lookup-symbol' searches the Python docs, customize Info as below. 
{{{
(require 'info-look)

(info-lookup-add-help
 :mode 'python-mode
 :regexp "[[:alnum:]_]+"
 :doc-spec
 '(("(python)Index" nil "")))
}}}

====Using a web browser====
[http://github.com/tsgates/pylookup Pylookup mode] allows searching the Python documentation from Emacs and viewing results in a web browser, either on- or off-line.

=== IronPython ===
* Install [ProgrammingWithPythonModeDotEl python-mode]
* ##(setq py-jython-command "c:/Program Files/IronPython 2.6 for .NET 4.0/ipy.exe")##
* Open a .py file. C-c C-t will toggle "jython", C-c ! will start a shell
===Cython===
See CythonMode

===Editing pip requirements files===
[https://melpa.org/#/pip-requirements pip-requirements] is a major mode for editing pip requirements files, with support for syntax highlighting, togglable comments and auto-completion of package names from !PyPI.

==Troubleshooting==
=== Unicode encoding in python-shell on Mac OS X ===
(This problem does not occur when using Python 3, macOS 10.15, and Emacs 27.1 from https://emacsformacosx.com. It also should not appear in [[AquamacsEmacs]].).

When using Emacs 24.1 on Mac OS X compiled via homebrew, the python-shell always used US-ASCII as encoding. To fix it I used:
<pre>
(setenv "LC_CTYPE" "UTF-8")
(setenv "LC_ALL" "en_US.UTF-8")
(setenv "LANG" "en_US.UTF-8")
</pre>

To determine your encoding in the python-shell use:
<pre>
>>> import sys; sys.stdout.encoding
'US-ASCII'
</pre>

Not having the right encoding set leads to errors in ipython:
<pre>
ERROR - failed to write data to stream: <_io.TextIOWrapper name='<stdout>' mode='w' encoding='US-ASCII'>
</pre>

=== Too many __init__.py buffers ===
In large Python projects, you may end up having lots of buffers similarly named __init__.py<XXX>.
PACK/__init__.py contains the code for a Python package PACK.
It is handy to name the buffers differently, here "PACK.py", as if there was a real file of this name.
To do this:

{{{
(defun my-create-file-buffer (args)
  "Advice for `create-file-buffer' to use better names than \"__init__.py\".
When the filename is /path/to/package/__init__.py,
I want \"package.py\" as the buffer name.
This advice is intended to be used like this:
(advice-add 'create-file-buffer :filter-args #'my-create-file-buffer)"
  (let* ((filename (nth 0 args))
         (lastname (file-name-nondirectory filename)))
    (if (string-equal lastname "__init__.py")
        ;; Use the directory name and add ".py" to it
        (list (concat (file-name-nondirectory (directory-file-name (file-name-directory filename))) ".py"))
      args)))
(advice-add 'create-file-buffer :filter-args #'my-create-file-buffer)
;; to remove:
;;(advice-remove 'create-file-buffer #'my-create-file-buffer)
}}}

==How to improve this page==
Round out support features in line with https://lists.gnu.org/archive/html/emacs-devel/2015-10/msg00669.html

Add sections on: semantic editing (a la paredit), 

Extend sections on: refactoring, code navigation.

Add a feature comparison table for packages?

----
Categories: CategoryProgramming, ProgrammingModes
