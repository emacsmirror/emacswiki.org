[[ja:PythonProgrammingInEmacs-ja]]
[[ja:PythonProgrammingInEmacs-ja]]
This page collects information for creating a usable Python programming environment in Emacs.
==Quick start==
Emacs already has out-of-the-box Python support via `python-mode'.  The IDE packages listed below can be used to set up a more complete environment quickly.
== Python Modes ==
There are a number of Python major modes for Emacs. As well as basic editing these all provide a range of IDE-like features, relying on a mix of native Emacs features and external Emacs/Python packages:
* [ProgrammingWithPythonDotElGallina python.el], which comes with Emacs 24.2 and up.
* [ProgrammingWithPythonModeDotEl python-mode.el] (same as python-mode.el listed below under IDE packages).
* [ProgrammingWithPythonDotEl 'loveshack' python.el] from Emacs 24.1 and before has a number of fans as well.
== IDE packages==
These provide powerful and relatively complete environments by combining and customizing other packages, both Emacs Lisp and Python, and resolving conflicts between them. 
* [https://github.com/jorgenschaefer/elpy Elpy]
* [https://github.com/tkf/emacs-jedi Jedi]
* [https://github.com/proofit404/anaconda-mode anaconda-mode] 
* [https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/python Python layer] for [[Spacemacs]].  Builds on anaconda-mode and several other packages.
* [ProgrammingWithPythonModeDotEl python-mode.el].  Replaces the `python-mode' in python.el.
== Support Features ==
Various features that can be added to or improved in Emacs.  Note that the IDE packages listed above provide many of these using packages referred to below.

===Virtual Environments==
There is some built-in support for virtual environments in python.el, but these packages provide more features.
* [https://github.com/jorgenschaefer/pyvenv pyvenv] - used in elpy, written by the same author. 
* [https://github.com/tkf/emacs-python-environment python-environment] - used in jedi, written by the same author.
* [https://github.com/proofit404/pyenv-mode pyenv-mode] - uses [https://github.com/yyuu/pyenv pyenv], written by the author of anaconda-mode.
* [https://github.com/pwalsh/pipenv.el pipenv.el] - A [https://docs.pipenv.org/ Pipenv] porcelain inside Emacs. 
* [https://github.com/porterjamesj/virtualenvwrapper.el virtualenvwrapper].
* [https://github.com/aculich/virtualenv.el virtualenv.el] - deprecated. 
* [https://github.com/necaris/conda.el conda.el] - for working with conda environments.
* [https://github.com/mukuge/npy.el npy.el] - for a nicer integration of Pipenv virtualenvs and inferior python processes.

To automatically activate virtual environment you can use:
* [https://github.com/robert-zaremba/auto-virtualenvwrapper.el auto-virtualenvwrapper] - uses virtualenvwrapper.
* [https://github.com/marcwebbie/auto-virtualenv auto-virtualenv] - uses pyvenv.
* [https://github.com/necaris/conda.el conda.el] and its minor mode conda-env-autoactivate-mode.
* [https://github.com/pwalsh/pipenv.el pipenv.el] - with [http://batsov.com/projectile/ Projectile].

===Indentation===
The defaults should see you compliant with PEP8 but see IndentingPython for detail.

=== Comment/Uncomment Region ===
If you have `transient-mark-mode' on, you can just use `comment-dwim': select a region and hit `M-;'. The DoWhatIMean means that it will comment or uncomment the region as appropriate. If you do not have `transient-mark-mode' on by default, you can hit C-SPC twice to activate it temporarily.

[ProgrammingWithPythonModeDotEl python-mode.el] also provides `py-comment-region and commands to comment/uncomment all known forms, def, block, clause etc.

===Completion===

Note that some IDE packages provide completion, e.g. Elpy provides completion using either jedi or rope as a backend to CompanyMode, and anaconda-mode provides completion via CompanyMode or AutoComplete.

You can also configure completion by using either jedi or rope as a backend to either CompanyMode or AutoComplete.

For [https://github.com/davidhalter/jedi jedi]:
* [https://melpa.org/#/company-jedi company-jedi] provides a backend for CompanyMode.
* [https://github.com/tkf/emacs-jedi Jedi.el] provides a backend for AutoComplete.

For [https://pypi.python.org/pypi/rope rope]:
* [https://github.com/python-rope/ropemacs Ropemacs] can be used as a backend for both CompanyMode and AutoComplete.

An experiment:
* [https://github.com/tavisrudd/emacs.d/blob/master/dss-completion.el AutoComplete support in IPython shell buffers]

===Code navigation===

The built-in [https://www.emacswiki.org/emacs/ProgrammingWithPythonDotEl python.el] has support for [https://www.emacswiki.org/emacs/ImenuMode imenu] code navigation. By default it uses a tree structure for navigation which presents only top level definitions that can then be 'drilled in to'. If you prefer a flat menu then you can add the following snippet (retrieved from [https://github.com/fgallina/python.el/issues/135#issuecomment-18459589 GitHub]) to your [https://www.emacswiki.org/emacs/InitFile init file]:

{{{
(defun python-imenu-use-flat-index
    ()
  (setq imenu-create-index-function
        #'python-imenu-create-flat-index))

(add-hook 'python-mode-hook
          #'python-imenu-use-flat-index)
}}}

The tools built on jedi support using it to find definitions. [https://github.com/tkf/emacs-jedi-direx jedi-direx] provides a tree-style source code viewer for Python buffers but is not on MELPA.

[[Helm]] provides an interface for navigating buffers via `helm-semantic-or-imenu'. 

[https://melpa.org/#/helm-cscope helm-cscope] provides a Helm interface to [https://melpa.org/#/xcscope xcscope].  [https://pypi.python.org/pypi/pycscope/ pycscope] supports generating the required cscope index of Python source trees.

=== Code generation helpers ===
====yasnippet====
[[Yasnippet]] comes with a broad set of templates for Python.
====sphinx-doc====
[https://melpa.org/#/sphinx-doc sphinx-doc] supports inserting and updating docstring skeletons
as used by [http://www.sphinx-doc.org Sphinx].  
====python-docstring====
[https://melpa.org/#/python-docstring python-docstring] is a minor mode for intelligently
reformatting (refilling) and highlighting Python docstrings. It understands both epytext and Sphinx formats (even intermingled!), so it knows how to reflow them correctly. It will also highlight markup in your docstrings, including epytext and reStructuredText.
====org-recipes====
[https://github.com/tuhdo/org-recipes org-recipes] A code snippet manager with Org and Helm. It is not specific to python and does not expand snippets like yasnippet does, but has the added benefit of combining text with org-mode source blocks that can then be inserted in a buffer via Helm.

===Lint, style and syntax checkers===
Both [[Flycheck]] and [[FlyMake]] can be used to wrap checkers such as pep8, pyflakes (flake8 includes both), pylint and pychecker.
====Flycheck====
[[Flycheck]] integrates flake8 and pylint.  It can be used with multiple checkers per buffer.
==== Flymake====

[[FlyMake]] uses pyflakes out of the box - just enable Flymake.

You can also configure Flymake to use flake8 or pylint.

Old versions of Flymake didn't support having multiple checkers per buffer, but this is now supported natively.


===Refactoring===
====Refactoring libraries====
[https://github.com/python-rope/ropemacs Ropemacs] is a library using [[Pymacs]] to talk with the Rope refactoring library.

[https://github.com/tkf/emacs-jedi Jedi.el] also has some refactoring support.

====Reformatting and PEP8 conformance====
=====yapf=====
[https://github.com/google/yapf Yapf] attempts to format Python code to the best formatting that conforms to a style guide, even if the original code didn't violate the style guide.  The style guide can be customized; predefined ones include pep8 and google.

Both [https://melpa.org/#/py-yapf py-yapf] and [https://github.com/jorgenschaefer/elpy Elpy] support applying yapf to the current buffer.

=====autopep8=====
[https://pypi.python.org/pypi/autopep8/ autopep8] formats Python code to conform to the PEP 8 style guide using [https://pypi.python.org/pypi/pep8 the pep8 tool].

Both [https://melpa.org/#/py-autopep8 py-autopep8] and [https://github.com/jorgenschaefer/elpy Elpy] support applying autopep8 to the current buffer.

=====Tidying imports=====
[http://melpa.org/#/py-isort py-isort] using [https://pypi.python.org/pypi/isort isort].

Elpy supports using [https://pypi.python.org/pypi/importmagic importmagic].

[https://github.com/anachronic/importmagic.el importmagic.el] automatically insert missing imports using [https://pypi.python.org/pypi/importmagic importmagic].

===Running tests===
[https://melpa.org/#/nose nose] and [https://bitbucket.org/durin42/nosemacs nosemacs] support running nose tests.

Elpy supports the standard unittest discovery runner, the Django discovery runner, nose and py.test

[https://melpa.org/#/pytest pytest] supports the [http://pytest.org pytest Python package], thus tests written with pytest, nose, unittest and doctest style test suites, including Django and trial.

===Reporting test coverage===
[https://melpa.org/#/pycoverage pycoverage] generates reports using  [https://pypi.python.org/pypi/coverage coverage] and provides a minor mode for displaying coverage by overriding `linum-mode'.  Alternatively, a [[Flycheck]] checker could be used to display coverage.

===Debugging===

====gud====
The native `python-mode' supports pdb tracking via the GrandUnifiedDebugger: when you execute a block of code that contains some call to Python's pdb (or ipdb) it will prompt the block of code and will follow 
the execution of pdb marking the current line with an arrow.  

To debug a script run the Emacs command "M-x pdb" and invoke Python's pdb as 
"python -m pdb foo.py"

====realgud====
[https://melpa.org/#/realgud realgud] provides support for pdb, ipdb and trepanning debuggers.  [https://github.com/rocky/emacs-dbgr/wiki/Features Its features not in the gud] include single-keystroke debugger commands inside the source code.

=== Interactive environments - Shells, REPLs and notebooks ===
====Using IPython as the Python shell==
In Emacs's native python-mode, use:
{{{
  (setq python-shell-interpreter "ipython"
       python-shell-interpreter-args "-i")
}}}
This should work with any recent IPython, including on Windows.

Since IPython 5 it has a new terminal interface, which is not compatible with Emacs' inferior shells. To fix it, add the --simple-prompt flag to the IPython command:

{{{
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "--simple-prompt -i")
}}}

[ProgrammingWithPythonModeDotEl python-mode.el] also comes with IPython support. 

Note that the built-in commands `python-send-shell-region', `python-send-shell-buffer', etc. do not support ipython magic commands. See [https://github.com/jackkamm/ipython-shell-send-el ipython-send-shell] for replacements that support ipython magic. 

====Emacs IPython Notebook (EIN)====
[https://github.com/millejoh/emacs-ipython-notebook Emacs IPython Notebook (EIN)] provides a IPython Notebook client and integrated REPL (like SLIME) in Emacs. It is available on MELPA as 'ein'.  Replaces [https://github.com/tkf/emacs-ipython-notebook tkf's EIN], which it was [https://github.com/tkf/emacs-ipython-notebook/issues/156 forked from] to keep up with IPython/Jupyter development. 
==== ob-python====
[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-python.html ob-python] provides Org-Babel support for evaluating Python source code.  Python source code blocks in Org Mode can be used to define functions, filter and analyze data, create graphics and figures, and produce reproducible research papers using a style similar to literate programming. It is included in the 'org-plus-contrib' package from [http://orgmode.org/elpa.html the Org Mode ELPA] or [[MELPA]].
====ob-ipython====
[https://github.com/gregsexton/ob-ipython ob-ipython] provides Org-Babel support for evaluating Python source code using an IPython kernel.  It provides similar features to ob-python (and tries to be more robust) as well as IPython-specific features like magics.  
====LaTeX or MarkDown====
[https://github.com/burakbayramli/emacs-ipython emacs-ipython], an Emacs extension that allows execution of python code inside a LaTeX or MarkDown buffer and display its results, text or graphic in the section below. The extension uses Pymacs to connect to an ipython kernel to execute code. 
====Live coding====
[https://github.com/donkirkby/live-py-plugin live-py-mode] is a Python minor mode supporting live coding, inspired by Bret Victor's [https://vimeo.com/36579366 "Inventing on Principle"] .

===Cell-mode===
Some packages provide MATLAB-like cells support: navigation between cell code blocks and evaluation.

[https://github.com/wavexx/python-x.el python-x] also provides some additional features

[https://github.com/thisch/python-cell.el python-cell] provides Matlab-like cells in python buffers

===Viewing generated documentation===
This refers to documentation generated by [https://docs.python.org/2/library/pydoc.html pydoc] and similar tools.

Emacs' native python-mode supports ElDoc via `python-eldoc-at-point'. This returns documentation for object at point by using the inferior python subprocess to inspect its documentation.

[https://melpa.org/#/pydoc pydoc] supports generating and viewing pydoc documentation either in an Emacs help buffer, with enhancements like linking to code and coloring for readability, or in a web browser.

[https://melpa.org/#/helm-pydoc helm-pydoc] provides a helm interface to pydoc.

Elpy supports viewing documentation from jedi/rope, falling back to pydoc.

===Viewing the official Python documentation===
This refers to the documentation at https://www.python.org/doc/.
====Using Info====
You will first need to obtain Info files for the Python documentation.  These can be downloaded pre-built from https://github.com/politza/python-info, or built using the instructions there (They are not available at https://www.python.org/doc/).  

[https://bitbucket.org/jonwaltman/pydoc-info/ pydoc-info], available on MELPA, configures Info to use the Python docs, and provides customized support for Python. 

For more basic configuration, so that `info-lookup-symbol' searches the Python docs, customize Info as below. 
{{{
(require 'info-look)

(info-lookup-add-help
 :mode 'python-mode
 :regexp "[[:alnum:]_]+"
 :doc-spec
 '(("(python)Index" nil "")))
}}}

====Using a web browser====
[http://github.com/tsgates/pylookup Pylookup mode] allows searching the Python documentation from Emacs and viewing results in a web browser, either on- or off-line.

=== IronPython ===
* Install [ProgrammingWithPythonModeDotEl python-mode]
* ##(setq py-jython-command "c:/Program Files/IronPython 2.6 for .NET 4.0/ipy.exe")##
* Open a .py file. C-c C-t will toggle "jython", C-c ! will start a shell
===Cython===
See CythonMode

=== Unicode on Mac OS X === 
When using Emacs 24.1 on Mac OS X compiled via homebrew. The python-shell always used US-ASCII as encoding. To fix it I used:
<pre>
(setenv "LC_CTYPE" "UTF-8")
(setenv "LC_ALL" "en_US.UTF-8")
(setenv "LANG" "en_US.UTF-8")
</pre>

To determine your encoding in the python-shell use:
<pre>
>>> import sys; sys.stdout.encoding
'US-ASCII'
</pre>

Not having the right encoding set leads to errors in ipython:
<pre>
ERROR - failed to write data to stream: <_io.TextIOWrapper name='<stdout>' mode='w' encoding='US-ASCII'>
</pre>

===Editing pip requirements files===
[https://melpa.org/#/pip-requirements pip-requirements] is a major mode for editing pip requirements files, with support for syntax highlighting, togglable comments and auto-completion of package names from !PyPI.

===Running IPython within Emacs====
IPython complains about incomplete shell (e.g. for help(func)). 

Solution is to create an IPython profile then put

import pydoc
import sys
pydoc.help = pydoc.Helper(output = sys.stdout)

into nopager10.py in ~/.ipython/profile_default/startup/

and set for python.el

(setq python-shell-interpreter "ipython")
(setq python-shell-interpreter-args "-i --simple-prompt --InteractiveShell.display_page=True")

in init.el

===How to improve this page===
Round out support features in line with https://lists.gnu.org/archive/html/emacs-devel/2015-10/msg00669.html

Add sections on: profiling, semantic editing (?), 

Extend sections on: refactoring, code navigation.

Include new jupyter package: https://github.com/dzop/emacs-jupyter.
----
Categories: CategoryProgramming, ProgrammingModes
